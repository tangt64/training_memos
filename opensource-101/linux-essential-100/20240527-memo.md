# 리눅스 어드민 기본 과정

가상서버 2대 기반으로 랩을 진행 합니다.

## 랩에서 사용하는 가상머신 사양
* ISO 내려받기 주소[링크](https://download.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9.3-x86_64-minimal.iso)
* 하이퍼브이[링크](https://learn.microsoft.com/ko-kr/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)
  - windows 10/11 pro
* VirtualBox, VMware Player/Workstation
  - AMD CPU에서는 비권장(특히, VBox)
  - Fusion, VMware Player

## 강의실 정책
- 쉬는시간: 매 시간 50분 수업 후 15분 휴식
- 점심시간: 11시 40분 ~ 12시 50분(1시간 20분, 실제시작은 보통 1시)


```bash
vCPU: 2개(I3,I5), 사양이 부족하시면 1개로도 가능
vMEM: 2048MiB+ 
vDISK: 
  Node 1: OS=20GiB
          /dev/vda: OS, 20GiB  ## 따라오기 어려우시면, 일단 OS만 설치!!
          /dev/vdb: data, 2GiB
          /dev/vdc: data, 2GiB
          /dev/vdd: data, 3GiB
          HOSTNAME: node1.example.com
  Node 2: OS=20GiB
          /dev/vda: OS, 20GiB
          /dev/vdb: data, 2GiB
          /dev/vdc: data, 2GiB
          /dev/vdd: data, 3GiB          
          HOSTNAME: node2.example.com
```

# DAY 1

## 사용자 관리

### 사용자 비밀번호

1. adduser, GNU계열의 사용자 추가 명령어
2. useradd, BSD계열의 사용자 추가 명령어

```bash
whereis adduser(default)
whereis useradd(link, symbolic)
```

### 새로 추가된 옵션(systemd, btrfs, selinux)
---
1. --badname: 사용자 이름 형식 확인하지 않음.
2. --btrfs-subvolume-home: 사용자 홈 디렉터리를 서브볼륨의 구성.(레드햇 계열에서 사용 불가능)
3. --password: 사용자 패스워드 설정. 대신, openssl, mkpasswd를 통해서 사용이 가능. 
4. --root: chroot기능. 사용자를 가상의 네임스페이스 영역(컨테이너)에서 사용이 가능.

"2", "3", "4"번은 앞으로 많이 사용할 옵션.

```bash
                         groupmod
                   .---> usermod
                  /
             /etc/group
adduser ---> /etc/passwd <--- [systemd] --- <logind>
            ------------
              \
               `---> /etc/gshadow
                     /etc/shadow

getent ---> /etc/passwd
          > /etc/group
          > /etc/hosts

```

### 사용자 추가

```bash
## 1
adduser testuser0
passwd testuser0

## 2
adduser testuser1
passwd testuser1
echo rocky | passwd --stdin testuser1

## 3
dnf provides mkpasswd 
> mkpasswd
dnf install mkpasswd -y
mkpasswd -m sha-512
adduser testuser2 --password $6$U9eL0Hyz2aQQPkg6$7svxabfdis20VFAorDh99uTwqa.EjblifybBrYukqjUXC7AaoVLKsceVtSgMd7Dx1eIuHYIhJIJQ.HsktTq651
```

### 사용자 생성 확인

사용자 비밀번호를 콘솔에서 입력 후 접근하기 위해서 "sshpass"패키지 설치를 권장.

```bash
su - <USER>                                                     ## 비밀번호 없이 사용자 전환이 가능. 비밀번호 확인이 불가능.
ssh user1@node1.example.com                                     ## 비밀번호 입력 후 로그인이 되어야함.
> <PASSWORD>

dnf install sshpass -y
ssh testuser[1-2]@localhost
sshpass -p rocky ssh testuser1@localhost id
> uid=1001(testuser2) gid=1001(testuser2)
ssh user1@localhost
sshpass -p rocky ssh testuser2@localhost id
> uid=1001(testuser2) gid=1001(testuser2)
```


### 그룹 생성 및 사용자 추가

사용자 그룹 생성 시 사용하는 명령어는 아래와 같다.
- groupadd
- usermod
- groupmod

특정 사용자를, 특정 그룹에 편입 시키는 방법.
- 사용자 UID 그룹 GID 1000번으로 시작(systemd이후로 모든 리눅스는 1000번 이후로 사용)
- 일반적으로 그룹만 시스템에 추가하는 경우 GID를 1만번(10000) 이후부터 사용

```bash
/etc/passwd
0
  
499     > system account: kernel 
          service account: httpd, ftpd

999

1000    > normal user account

/etc/group
10000   > group GID additional range

```

```bash
groupadd testgroup -g 10000
usermod -aG testgroup testuser1
usermod -aG testgroup testuser2

grep testgroup /etc/group 
> testgroup:x:1003:testuser1,testuser2
  ---------        -------------------
  그룹이름               사용자들

groups testuser1
> testuser1 : testuser1 testgroup
              --------- ---------
              주 그룹    보조 그룹
```

### 사용자 확인

리눅스 사용자 확인을 위해서 보통 사용하는 방식이 'id', 'grep testuser1 /etc/passwd'와 같은 방법으로 한다.
앞으로 사용할 __표준 리눅스(LSB Linux)__ 에서는 다음과 같은 방식(getent)으로 사용자 확인을 권장.

```bash
getent
> Get entries from administrative database(/etc/passwd, /etc/group).
> 사용자 정보를 가져오는 명령어.

getent passwd testuser1
> testuser1:x:1002:1002::/home/testuser1:/bin/csh
getent group testgroup
             testuser1
> testgroup:x:1003:testuser1,testuser2
getent host node1.example.com
```

### 쉘 변경

1. usermod(default)
2. chsh(optional package)

```bash
dnf provides chsh
> util-linux-user
dnf install util-linux-user -y
dnf install zsh csh -y

## 쉘 정보를 확인하고 싶은 경우
chsh -l
> /bin/sh
> /bin/bash
> /usr/bin/sh
> /usr/bin/bash
> /usr/bin/zsh
> /bin/zsh
> /bin/csh

chsh -s /bin/zsh testuser2
usermod -s /bin/zsh testuser2
getent passwd testuser2
> testuser2:x:1001:1001::/home/testuser2:/bin/zsh
```

### 사용자 락(lock) 혹은 로그인 금지

특정 사용자가 더 이상 시스템에 로그인을 할 수 없도록 하는 요구사항.

1. 'usermod', 'chsh'로 쉘을 변경.(아내 메세지가 출력이 됨)
2. 'usermod -L'명령어로 사용자 잠금.(안내 메세지가 출력이 되지 않음)

보통 리눅스에서 로그인이 되지 않는 쉘은 다음처럼 구성 및 사용.

1. /usr/bin/false
2. /usr/sbin/nologin(default, 쉘 안내 메세지가 출력)

```bash
## 사용자를 로그인을 하지 못하도록 한다.
usermod -s /usr/sbin/nologin noshelluser
~~usermod -s /usr/sbin/false noshelluser~~
sshpass -p rocky ssh noshelluser@localhost
> This account is currently not available.
> Connection to localhost closed.


## 특정 사용자는 시스템 접근이 되지 않는다.
usermod -L baduser
getent passwd baduser

sshpass -procky ssh baduser@localhost
> Permission denied, please try again.
```

### 연습문제 1

예를 들어서 다음과 같이 사용자 및 그룹 구성.

|그룹이름  |사용자 이름 |ID값       |
|---------|------------|-----------|
| sharegrp|user1,user2 |GID: 10000 | 
| datagrp |            |GID: 11000 |
| devel   |user3       |           |
| infra   |user4       |           |
| cloud   |user5       |           |



```bash
## 먼저 그룹 생성 후 사용자 추가
chsh -l                                                  ## 쉘 목록 확인이 가능
cat /etc/shells                                          ## 쉘 목록 확인이 가능
usermod                                                  ## 계정 정보 변경

groupadd sharegrp -g 10000                               ## -g옵션을 통해서 사용자 그룹 gid값을 변경
groupadd datagrp -g 11000

adduser -u 10000 -G sharegrp -s /usr/bin/tcsh user1      ## UID + GID + SHELL 사용자 생성 
adduser -u 11000 -G datagrp  -s /usr/bin/nologin user2

echo "helloworld" | passwd --stdin user1                 ## 패스워드 설정
echo "helloworld" | passwd --stdin user2                 ## 패스워드 설정

id user1                                                 ## 사용자가 잘 추가가 되었는지 확인
id user2

adduser -G sharegrp user1
adduser -G sharegrp user2
cat /etc/group

## 사용자 추가 후, 그룹 설정

groupadd sharegrp -g 10000
tail -10 /etc/group

id user1

usermod -aG

# a: append
# G: GroupName

usermod -aG sharegrp user1
usermod -aG sharegrp user2
usermod -aG devel user3
usermod -aG infra user4
usermod -aG cloud user5

id user1
id user2
id user3
id user4
id user5
```

### 연습문제 2

랩에서 생성할 사용자 이름.
  - user1, bash
  - user2, 쉘 사용 금지 혹은 로그인 불가능 == nologin
  - user3, csh 
  - user4, tcsh
  - user5, fish

```bash
adduser user1
adduser -s /usr/sbin/nologin user2
adduser -s /usr/bin/csh user3
adduser -s /usr/bin/tcsh user4
adduser -s /usr/bin/fish user5
```

사용자 hacker는 csh를 사용한다.
사용자 twitter는 쉘 접근이 되지 않으며, sharegrp에 보조 그룹으로 가입이 되어있다.
모든 사용자 비밀번호는 명시되어 있는 비밀번호로 설정한다.


일반 사용자에게 쉘 권한을 비부여 하려면 아래와 같이 쉘 설정
  - 사용자가 추가가 되면, 보통은 /etc/passwd에 사용자가 추가
  - RHEL 7/8/9오면서 기본적으로 모든 사용자는 UID/GID 1000:1000으로 시작함

```bash
##
## 무조건 루트에서 작업
##

cat /etc/shells                  ## 모든 쉘 경로가 있음, nologin, false는 없음.

dnf install epel-release -y      ## fish설치하기 위해서 엔터프라이즈 패키지 저장소 설치
dnf install csh fish -y
cat /etc/passwd
adduser user1
echo $?                          ## 명령어 실행값 반환 확인. 0으로 반환이면 문제가 없음.
grep user1 /etc/passwd
adduser -s <SHELL_PATH>          ## chsh -l
adduser -s /usr/sbin/nologin
                                 ## cat /etc/shells
whereis false                    ## 로그인 차단
whereis nologin                  ## 로그인 차단, 권장
dnf install util-linux-user -y
chsh -l
chsh -s /usr/sbin/nologin user3
usermod -s <SHELL> user3         ## LSB(Linux Standard base)에서 권장
vi /etc/passwd
user3:x:1002:1002::/home/user3:/usr/bin/tcsh

userdel -r user3                 ## -r home디렉터리 삭제
userdel -r user2  
userdel user1                    ## rm -rf /home/user1
```
만약 "Creating mailbox file: File exists"메일 박스 오류가 발생하는 경우.
```bash
userdel user1
adduser user1
Creating mailbox file: File exists
rm -f /var/spool/mail/user1
```

### 사용자 정보 수정

1. 사용자 제거

```bash
adduser incorrectuser
userdel -r incorrectuser

getent passwd incorrectuser

echo $?         ## 0: 정상, 1: 비정상
```

2. 사용자 정보 수정

```bash
usermod -u 15000 incorrectuser
getent passwd incorrectuser
> 15000
groupmod -g 15000 incorrectuser
> 15000
usermod --login correctuser incorrectuser
usermod --login correctuser --move-home /home/correctuser incorrectuser 
groupmod --new-name corretuser incorrectuse
mkdir -p /home/correctuser 
usermod --home /home/correctuser correctuser
getent passwd correctuser
> correctuser:x:150000:150000::/home/correctuser:/bin/bash
```

## DNF3/YUM

### dnf, yum 차이점
RHEL 8버전 이후부터는 yum명령어에서 RHEL 9부터는 dnf명령어로 세대 교체가 됨. 
dnf에서는 추가적으로 __module__ 기능을 지원하며, yum에 비해서 실행속도 및 메모리 사용량이 작고 빠름.

명령어 위치 확인.
```bash
whereis dnf
whereis yum
```

1. 저장소 관련(RHEL vs CentOS vs Rocky)

- appstream                                              Rocky Linux 9 - AppStream
- baseos                                                 Rocky Linux 9 - BaseOS
- extras                                                 Rocky Linux 9 - Extras

"appstream"에서 추가된 패키지는 앞서 이야기한 "module package"가 추가가 됨.
```bash
dnf module list
> nginx[1.22]
> nginx[1.24]

dnf info nginx
> 1.20
dnf module install nginx:1.24
```

2. 변경된 명령어 도구(yum-utils)

- yum-config-manager: yum-utils
- dnf config-manager: dnf command(default) 

```bash
rm -f /etc/yum.repos.d/*
ls -l /etc/yum.repos.d/
> N/A 

## 1번
dnf config-manager --add-repo=http://localhost/rpms

## 2번 
dnf install yum-utils
yum-config-manager --add-repo=http://localhost/rpms
> /etc/yum.repos.d/localhost.repo

dnf clean all
dnf search httpd-core

## SELinux에 차단중
setenforce 0 

vi /etc/yum.repos.d/localhost.repo
> [localhost]
> name=created by dnf config-manager from http://localhost
> baseurl=http://localhost
> enabled=1
> gpgcheck=0
dnf install vsftpd -y
```

3. 저장소 구성

```bash
dnf install yum-utils -y
vi ~/.tmux.conf
> set-option -g mouse on
> bind -n WheelUpPane if-shell -F -t = "#{mouse_any_flag}" "send-keys -M" "if -Ft= '#{pane_in_mode}' 'send-keys -M' 'select-pane -t=; copy-mode -e; send-keys -M'"
> bind -n WheelDownPane select-pane -t= \; send-keys -M
tmux
dnf install httpd httpd-core -y
mkdir -p /var/www/html/rpms
rm -f /etc/yum.repos.d/localhost.repo
dnf reposync -p /var/www/html/rpms
dnf install createrepo_c -y
createrepo_c /var/www/html/rpms
systemctl enable --now httpd
```

### 상규님 질문 :)

여러 버전의 RPM파일을 오프라인으로 저장소 형태로 만들고 싶은 경우(dnf기준) 다음과 같이 진행.

```bash
mkdir -p /var/www/html/rpms/9.0
reposync --releasever 9.0 -p /var/www/html/rpms/9.0/
createrepo /var/www/html/rpms/9.0/
mkdir -p /var/www/html/rpms/9.1
reposync --releasever 9.1 -p /var/www/html/rpms/9.1/
createrepo /var/www/html/rpms/9.1/
```


3. 패키지 관리

1. RPM명령어(rpm)

이 명령어는 오프라인 상태에서 사용이 가능. 저장소 없이 사용 가능.
```bash
rpm -qi httpd-core         ## 패키지 정보
rpm -ql httpd-core         ## 파일 목록
rpm -qf /usr/sbin/httpd == dnf provides httpd
rpm -qa httpd
rpm -qa | grep httpd 
rpm -e httpd-core
```

2. dnf/yum 

이 명령어는 오프라인에서 동작하지 않음. disconnected 혹은 폐쇠망에 저장소가 구축이 안되어 있으면 사용이 불가능.

```bash
dnf provides httpd
dnf install httpd
dnf remove httpd
dnf update 
```

### 종합문제(사용자/그룹/저장소/패키지)

완료하시면 화면에, __"done-lab"__ 이라고 챗팅창에 남겨 주세요.

1. 로그인 가능하다.         == 쉘 사용이 가능.
2. 시스템 접근이 불가능하다. == 쉘 사용이 불가능.

- 사용자 www-hacker, www-user, data-user 그리고 db-user를 생성한다.
- 모든 사용자는 비밀번호를 rockylinuxworld라고 설정한다.
- 사용자 www-hacker는 웹 서비스(httpd)에 접근은 가능하나, 시스템에 접근은 불가능하다.
  - apache라는 그룹에 포함이 된다.
  - www-hacker는 반드시 보조그룹으로 apache에 가입된다.
- www-user,data-user는 secure-data그룹에 포함이 된다.
  - 각 사용자는 tcsh를 통해서 시스템에 접근이 가능하다.
  - 그룹 secure-data가 없는 경우, 사용이 가능하도록 생성한다.
  - GID번호를 13000번으로 설정한다.
- db-user는 wheel그룹에 포함이 되며, 시스템에 로그인이 가능하다.
- 각각 사용자를 ssh로 접근 후 "id"명령어 실행한다.
- 패키지 vsftpd를 설치한다.

- node2에 저장소를 추가한다.
  - "http://172.24.48.199/rpms/"으로 사용하도록 설정한다. 저장소 이름은 "node1"으로 한다.
  - 기존 저장소 파일은 전부 제거한다.
  - 다만, 저장소 미러링 하지 않는 경우, 기존 저장소 파일 제거하지 않는다.
  - 추가된 저장소가 잘 보이는지 'dnf repolist'로 확인한다.
  - 올바르게 구성이 되었으면 httpd패키지를 설치한다.

```bash
www-hacker, rockylinuxworld, www-user, nologin
www-user, rockylinuxworld, secure-data
data-user, rockylinuxworld, secure-data
db-user, rockylinuxworld, wheel

node1

firewall-cmd --add-serivce=http

```



```bash
                   .---> passwd 
                  /
              -----------
adduser  ---> /etc/passwd--. 
                           \
                            @ <----- usermod -aG
                           /
groupadd ---> /etc/group--' 
              ----------
                 \
                  '---> groupmod

whereis nologin     ## false
```

## SELINUX

1. SELinux(MAC): 커널수준에서 시스템 콜 접근 제어.
2. chmod/chown(DAC): 명시된 영역(사용자 혹은 퍼미션)으로 접근 제어.

이전에는 레드햇 계열만 사용하다가, 현재 모든 리눅스 배포판에서 사용하고 있음. NIST(미국)에서 지원하는 보안 솔루션 중 하나.

현재 오픈 소스에는 두 가지 MAC보안 모델 프로그램이 제공되고 있음.

- AppArmor, GNU
- SELinux, NSA -> OpenSource

현재 사용중인 리눅스에서 SELinux동작 상태 확인. 아래 명령어는 임시적으로 사용하는 명령어.
```bash
getenforce
> 1: enforcing
> 0: permissive
setenforce 0
```

영구적으로 SELinux적용 상태를 변경하기 위해서는 다음과 같이 명령어를 사용해야 됨.

1. /etc/sysconfig/selinux
2. /etc/selinux/config(default)

```bash
ls -l /etc/selinux/
> config
vi /etc/selinux/config
> SELINUX=enforcing  
> SELINUX=permissive
systemctl daemon-reload             ## systemd에 변경내용 반영 요청
dracut -f                           ## 램 디스크 강제 갱신
```

```bash
setenforce 0
vi /etc/selinux/config
> SELINUX=permissive
systemctl daemon-reload

```

"SELINUXTYPE="에 사용하는 옵션은 다음과 같다.

1. targeted: 기본적으로 프로세스 기반으로 모니터링.
2. mls: 다중보안 사용. 보통 수준별 접근이 필요한 경우 사용. NIST에 명시가 되어 있음.
3. minimum: 컨테이너 시스템과 같이 제한적으로 접근 제한이 필요한 경우.

아래와 같이 포트변경 작업을 수행한다.(node2)

```bash
dnf install httpd-core httpd -y 
dnf provides semanage                                             ## 해당 명령어가 어떤 패키지에 포함이 되어 있는지 검색
dnf install policycoreutils-python-utils

semanage port -l | grep http 
> http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010                                                        
> http_cache_port_t              udp      3130                                                                                 
> http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000                                             pegasus_http_port_t            tcp      5988                                                                                
> pegasus_https_port_t           tcp      5989   

semanage port -a -t http_port_t -p tcp 8841                       ## 변경된 포트 
semanage port -lC                                                 ## 포트 리스트 확인 

systemctl start httpd
systemctl is-active httpd
systemctl is-active firewall                                      ## 방화벽 동작 여부
firewall-cmd --add-port=8841/tcp
firewall-cmd --runtime-to-permanent                               ## 방화벽에 등록된 포트번호를 영구적으로 적용
echo "welcome to NODE2 Server" > /var/www/html/index.html
restorecon -RFvv /var/www/html/
curl localhost:8841
```


### 연습문제(SELinux)
0. 기존에 설치한 웹 서비스 제거.(dnf remove httpd -y)
1. node2에 httpd서비스 설치 후 포트를 변경.
2. SELinux는 무조건 사용.
3. semanage명령어가 없는 경우, 올바르게 동작하도록 패키지 설치.
4. 포트번호는 8723/tcp로 http_port_t에 등록.
5. /var/www/html/index.html파일에서 "Hello Httpd Node2"메세지 출력.
6. 이 페이지는 반드시 외부에서 접근이 가능해야 됨.
7. 서비스는 리부팅 이후에도 반드시 시작 및 부트업이 되어야 함.
  1. systemctl enable --now httpd
  2. reboot


# DAY 2

## Q/A


1. BTRFS

레드햇 기준으로 7.3까지 BTRFS지원. ZFS/JFS/UFS2와 같이 엔터프라이즈 파일 시스템을 제공. 
기업용 파일 시스템에서 주요 기능 중 하나가 filesystem pool.

현재 대다수 리눅스는 LVM2(IBM)기반으로 filesystem pool를 제공하고 있으나, 여전히 관리 및 유지보수가 복잡하고 어렵다. 
이러한 이유로 btrfs에서는 pool기능을 제공하고, 하위 볼륨을(subvolume)형태로 파일 시스템 공간을 제공한다. 

2. 그러면 레드햇은...?

Fedora Linux에서는 여전히 BTRFS를 제공하고 있으며, 스트림 버전인 centos, RHEL에서는 여러가지 이유로 btrfs제공하지 않음.
BTRFS는 몇가지 단점이 있는데, 첫 번째가 XFS보다 속도가 느립니다. 두 번째가 BTRFS개발 도중에 크고 작은 파일 시스템 문제가 발생. 

XFS는 아직까지 유일하게 MILL-SPEC를 충족하는 파일 시스템. 이러한 이유로 레드햇 FILESYSTEM POOL를 Stratis라는 도구로 구현 함.


3. 결론

"--btrfs-subvolume-home"은 btrfs파일 시스템 전용이기 때문에, XFS에서 제공하는 Stratis기반의 pool에서는 사용이 안됨. 위 옵션은 레드햇 계열 배포판(xfs)에서는 사용이 불가능.


## crontab

앞으로 이 프로그램을 사용하지 않음. systemd기반에서는 ".timer"자원으로 지원하며, 본래 명칭은 "systemd-timer"라고 부른다.
systemd-timer에 통합된 자원은 다음과 같다.

1. at
2. crontab
3. anacrond

다수 배포판은 아직 crontab를 지원하기 때문에, 여전히 사용이 가능하다. 

crontab은 아래와 같은 방식으로 예약작업 등록이 가능하다.
```bash
crontab -l -u <USER>
crontab -e -u <USER>
```

/etc/cron.daily, /etc/cron.monthly와 같은 디렉터리는 "cronie-anacron"이라는 동기화 작업 스케줄러 서비스. 

```bash
ls -l /etc/cron*
> daily
> weekely
> monthly
rpm -qa cronie-anacron
rpm -ql cronie-anacron
> 
systemctl status crond.service 
systemctl is-enabled crond.service
systemctl is-active crond.service
```

이전에 crond에서 구성이 되었던 서비스는 현재는 전부다 systemd-timer로 이전이 되었음. 아래 명령어로 확인이 가능.

```bash
systemctl -t timer 
```

아직까지는 대다수 서비스는 crontab기반으로 구성 및 설정. "-u"옵션이 설정이 되어 있지 않으면, 기본적으로 root로 출력 및 편집.

아래는 crontab에서 사용하는 정책 설명.

"\*", 모든 분 혹은 모든 시간에 실행.

```bash
cat /etc/crontab                                         ## 정책 파일

# */1: 같은 동작, 권장은 "매 X분마다 실행" 

1 * * * *: 1시 1분, 2시 1분, 3시 1분.....
*/1 * * * *: 1시 1분, 1시 2분, 1시 3분...... 
```

```bash

## 매 1분마다 Hello Node1를 출력하라.
## 사용자 user3에게 작업을 할당.

# -e: edit의 약자, 특정 사용자의 작업 등록 및 편집
# -l: list의 약자, 특정 사용자의 작업 목록 출력
# -u: user의 약자, 사용자 지정

EDITOR=nano crontab -e -u testuser1  

crontab -e -u user3                                      ## 특정 사용자에게 작업 등록
crontab -l -u user3                                      ## 특정 사용자에게 등록된 작업 내용

ls -l /var/spool/cron/testuser1
cat /var/spool/cron/testuser1
> */1 * * * * echo hello world
```


### 작업 확인

```bash
journalctl -u crond -p info -fl
## 혹은   
tail -f /var/log/cron                                    ## 사용자 작업 파일
```

### 연습문제(node1)

사용자가 없는 경우, 사용자를 생성하고 아래와 같이 crontab작업을 등록한다.

1. 사용자 testuser3, testuser4를 생성한다. 암호는 rockylinux으로 한다.
2. 각 사용자에 "Hello hacker world this is 10 messages"메세지가 출력 되도록 한다.
3. 위의 매세지는 매 10분마다 출력되게 한다.



### grep

특정한 문자열을 포함하거나 혹은 시작과 끝 문자열을 검색한다. 많이 사용하는 옵션은 -R과 -i가 있다.

```bash
## 대소문자 상관 없이 검색 -i
## 하위 디렉터리까지 검색 -R

grep -Ri GNU /usr/share/doc/ 
grep -Ri GNU /usr/share/doc/ > /root/gnu_words.txt

grep -R GNU /usr/share/doc/ > /root/gnu_words.txt

grep -Ev '^#|^$' /etc/httpd/conf.d/httpd.conf
      ----
      -e: egrep 
      -v: excludes(제외)
```

### 연습문제(node1)
---

/usr/share/doc에서 license라는 대문자 단어만 찾아서 /root/materials/license.txt파일에 저장한다.


## 압축

1. tar: 여러 파일을 묶기 기능.
2. xz: 현재 대다수 리눅스 배포판은 .xz으로 압축파일 표준. 현재는 bz2대신 사용중.
3. gzip: GNU 라이센스 기반의 압축.
4. bzip2: 현재 레거시로 소프트웨어로 변경이 되어서 현재는 기본 값으로 설치가 안됨.
5. zip: BSD 라이선스 기반. 기존에 압축된 "winzip"를 파일을 풀때는, "unzip"를 통해서 해제 가능.

```bash
rpm -qa | grep zip
> bzip2-libs-1.0.8-8.el9.x86_64
> unzip-6.0-56.el9.x86_64
> gzip-1.12-1.el9.x86_64
> zip-3.0-35.el9.x86_64
> bzip2-1.0.8-8.el9.x86_64   

dnf install xz gzip -y
```

### 파일 묶기 

파일 압축 시, 보통 다음과 같은 과정으로 처리가 된다.

```bash

tar czf /root/archive.tar.gz  /usr/share/docs
    ---
    \
     `---> c: create
      ---> z: GNU Zip
      ---> f: file
gzip arhcive.tar
> archive.tar.gz      

tar cJf /root/archive.tar.xz /usr/share/doc
    ---
    \
     `---> J: XZ 

tar cf /root/archive.tar /usr/share/doc

tar xf -C /tmp archive.tar

xz /root/archive.tar
> archive.tar.xz

file archive.tar
>
file archive.tar.xz
> archive.tar.xz: XZ compressed data

tar cf --> <NAME>.tar --> xz <NAME>.tar --> <NAME>.tar.xz == tar cfJ <NAME>.tar.xz <TARGET>
```

### 주의사항

"-v" 옵션을 압축이나 혹은 해제하는 과정에서 사용하면, CPU 및 메모리 사용율이 올라감.

"tar: Removing leading `/' from member names"와 같은 메세지가 출력. 이 부분은 오류가 아니며, 아래 링크 참조.

[removing leading /](https://unix.stackexchange.com/questions/59243/tar-removing-leading-from-member-names)


### 연습문제

다음 디렉터리를 압축해서 /tmp에 보관.
- /usr/share/doc, bzip, doc.tar.bz2
- /usr/local, xz, local.tar.xz
- /var/log, gzip, log.tar.gz


## 파일 및 디렉터리 검색 

find명령어는 다음과 같이 사용한다.

정확하게 문자열 일치.
```bash
find / -name test -type f -print
```

문자열일 포함이 되어 있는거.
```bash
find / -name *test -type f -print
```

특정 결과를 실행하는 옵션.
```bash
# -print: newline
# cp test1
# cp test2
find / -name *test -type f -print -exec cp -a {} /tmp \;
                                 |
    /usr/bin/gr2fonttest        --->  cp -a {} /tmp/ \;
    --------------------                 --
           표준출력                       \
                                          `---> 파일 속성 그대로 복사.
                                      표준입력으로 전달
# -print0: none-newline 
# cp test1 test2
find /tmp/ -name '*test' -type f -print0 | xargs -0 /bin/rm -f 
           표준출력                --->    표준입력
man find
> exec                                          
```

쉘 스크립트 작성 시, 가급적이면 __샵뱅(#!)__ 를 넣어주세요.

```bash
vi search.sh
> #/bin/bash
> find / -atime +365 -size +500M -type f -print -exec cp -a /tmp/latest_access_files/ {} \;
```

```bash
#!/bin/bash
mkdir -p /root/test_files/
find / -name *test -type f -print -exec cp -a {} /root/test_files \;
```

```bash
## stat <파일경로> 
stat /usr/libexec/grubby/rpm-sort
  File: /usr/libexec/grubby/rpm-sort
  Size: 15736           Blocks: 32         IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 67322266    Links: 1
Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Context: system_u:object_r:bin_t:s0
Access: 2023-05-15 11:00:02.925008563 +0900 <-- 이 부분이 -atime(access time) 기록
Modify: 2022-11-02 08:09:40.000000000 +0900
Change: 2023-05-15 10:59:13.740214202 +0900
 Birth: 2023-05-15 10:59:13.740214202 +0900

``` 

### find 옵션 설명

1. -mtime: 파일 변경 시간 조건.
2. -atime: 파일 접근 시간 조건.
3. -user: 사용자 이름.
4. -type: 자원 형식. file=f, directory=d, link=l
5. -perm: 퍼미션 유형. 0700,rwx.
6. -exec: find에서 나온 출력 결과물을(stdout) 다른 명령에서 표준입력(stdin)으로 실행.
7. -size: 특정 크기의 파일을 검색.
8. -nouser: 사용자가 지정이 안된 파일.
9. -nogroup: 그룹이 지정이 안된 파일.
10. -print: newline.
11. -print0: none-newline.


시스템에 사용자나 혹은 그룹이 할당이 안된 파일을 찾고 싶은 경우.

```bash
adduser testuser00
userdel testuser00
find / -nouser -nogroup           ## 사용자 및 그룹이 선언이 안되어 있는 파일
```


```bash
mkdir -p /tmp/wrongfiles/

find / -user user1 -type f -print 

touch /usr/share/doc/user1.txt
chown -Rf user1. /usr/share/doc/user1.txt

find / -user user1 -type f -exec cp -a {} /tmp/user1_backup \;
                                       --

                    .---------------------------->      /home/user1/.bash_profile x 10
                   /          표준출력                  -------------------------
                  /                                                  |
  ---------------------------------                                  v
{ find / -user user1    -type   f   }     -perm 644    -exec cp -a {   } /tmp/wrongfiles/ \; x 10
               -----           ---              ---                -----               --
               사용자         자원형식                              치환              명령어 끝
```

### 연습문제

- 사용자 user1/2/3/4/5를 생성. 없으면 사용자 구성. 비밀번호는 rockylinux으로 설정.
  + 각 사용자 홈 디렉터리에 README.txt파일이 있어야 됨.
  + 각 README.txt파일은 올바르게 소유권 및 퍼미션 구성이 되어 있어야 됨.
- /tmp/user1, user2, user3, user4, user5 백업 디렉터리 생성.
- 각각 사용자가 사용하고 있는 모든 파일 및 디렉터리를 각각 백업 디렉터리에 복사.
- 복사된 백업 디렉터리 내용은 gzip로 압축.
- 스크립트 파일 이름을 backup_user.sh으로 생성.
  + 이 스크립트는 사용자 user5를 백업한다.
  + user5사용자만 xz파일로 압축한다.
  + 백업 위치는 /opt/backup-user/user5
  + 모든 작업은 스크립트로 동작한다.
  + 파일 압축도 스크립트로 진행한다.



## 네트워크 설정

현재 모든 리눅스 배포판은 다음과 같이 네트워크 관리자를 변경하고 있음.

1. NetworkManager
2. systemd-networkd(default)
3. netplan(ubuntu)
4. SuSE(wicked)


네트워크 스크립트가 레드햇 기준 9버전부터 더 이상 지원하지 않음. 어떻게 하면, 기존 스크립트를 호환하면서 사용이 가능할지?

```bash
NetworkManager --print-config
> # plugins=
vi /etc/NetworkManager/NetworkManager.conf
> plugins=keyfile,ifcfg-rh 
systemctl restart NetworkManager
nmcli connection migrate --plugin ifcfg-rh
ls -l /etc/sysconfig/networ-scripts/
> ifcfg-eth0
```


### 호스트이름 변경

1. 이전에는 "/etc/HOSTNAME"파일이나 혹은 "/etc/sysconfig/networks"에서 "HOSTNAME="값을 변경.
2. 현재는, 표준 방식으로 다시 변경.(유닉스 표준은 /etc/hostname에 저장).
3. systemd에서는 호스트 이름 변경을 'hostnamectl'으로 권장.

#### nmtui기반으로 변경

```bash
nmtui hostname node1.example.com
```

#### hostnamectl기반으로 변경.

```bash
hostnamectl set-hostname node1.example.com    ## 호스트 이름 변경
hostname                                      ## 호스트 이름 확인
hostnamectl
```

#### 파일로 생성 확인

```bash
cat /etc/hostname
```


### 네트워크 구성

1. 현재 사용중인 네트워크를 static으로 변경.
2. node1, node2번에 네트워크를 하나 더 추가.

작업 시 사용이 가능한 도구.

- nmcli(CLI)
- nmtui(TUI,prefer)
- nm-connection-editor(GUI)


현재 컴퓨터의 아이피 주소 및 라우트(게이트웨이)주소 확인. 'ifconfig'명령어는 더 이상 사용하지 않음.

```bash
ip link                                     ## 현재 서버의 네트워크 장치 확인
ip addr show  ---> ip a s                   ## 장치 아이피 주소 확인
ip r          ---> ip route / route         ## 라우팅 주소 확인
```



### 프로파일 변경 방법

```bash
nmtui edit
nmcli con sh
ip a s eth1
nmcli con up eth1
nmcli con sh eth1 | grep method
> ipv4.method:                            manual 
```

### 프로파일 제거 방법

```bash
nmcli con sh
nmcli con del eth1
nmtui edit
```



### 연습문제

노드1/2번에 eth1장치를 추가 후 아래와 같은 작업 수행.

- 이미 구성이 된 프로파일(profile)은 제거 후 진행.
- 인터페이스 이름은 internal.
  + 아이피 주소는 192.168.50.12으로 추가.
  + 넷마스크는 255.255.255.0으로 설정.
    * 이 부분은 비트(cidr)로 처리해야 됨
  + 게이트웨이는 192.168.50.1.
  + 도메인 정보는 192.168.50.1.
- 리부팅 이후에도 정보는 계속 남아 있어야 됨.


## 소유권 및 퍼미션

가급적이면 8진수 기반으로 퍼미션 조정은 하지 마시고, 심볼릭 기반으로 설정 권장.

```bash
chmod
          0       1       2      3      4      5     6     7    =    8진수(case문으로 구성됨)
                  x       w      wx     r      rx    rw    rwx

- chmod 744 <FILE>   1. 사용은 가능하지만, 비권장. 8진수로 하는 경우 숫자 계산이 필요
- chmod u+rwx <FILE> 2. GNU에서는 이 방식으로 사용을 매우 권장

chown
- chown tang.     <FILE> 3. "4번"과 동일한 효과
- chown tang:tang <FILE>  == chown tang.
                          == chown tang.grp
```

__심볼릭__

|값|이름   |
|--|-------|
|u | user  |
|g | group |
|o | other |
|a | all   |
|X | 디렉터리만 적용  |


| 값  | 이름      | 설명 |
|-----|-----------|------|
| u+s | bit key   | 디렉터리 및 실행파일에 적용, 프로그램이 실행할때 소유권자로 실행 --s                  | 
| g+s | bit key   | 디렉터리에 적용. 적용된 디렉터리 밑으로 파일이나 디렉터리는 그룹권한 상속. --g        |
| o+t | stick key | 디렉터리에 누구나 생성이 가능하나, 자신이 생성한 파일이나 혹은 디렉터리 제거 가능 --t |

|기호|설명         |
|----|-------------|
|+   | 퍼미션 추가 |
|=   | 퍼미션 대응 |
|-   | 퍼미션 제거 |

__MAC:__ SELinux and Mandatory Access Control (MAC)
  - selinux
  - apparmor
__DAC:__ discretionary access controls (DAC)
  - chown
  - chmod
__ACL:__ Access Control List (ACL)
  - setfacl/getfact

[mac/dac 차이점](https://www.twingate.com/blog/other/access-control-models)

```bash
chmod u+x   , g+r  , o=       <FILE OR DIR>
      u-w
      u=rwx

chmod -Rf u=rwX --> 모든 파일에는 실행 권한 할당하지 않음
                    실행 파일 및 디렉터리만 권한 유지
```      

o+t(1000): 스틱키(sticky)는 chmod명령어로 선언가능.
  - o+t, o+s는 잘못된 값이지만, 시스템에서는 오류로 표시가 안됨(echo $?)
  - 모든 사용자가 특정 디렉터리에서 파일 및 디렉터리 생성
  - 다른 유저는 자신이 만든 파일이나 디렉터리 제외하고 제거 불가능
           
1. user bitkey에 대표적인 예제는 'sudo'
2. sticky의 대표적인 예제는 "/tmp/"디렉터리

### group bitkey 구성

```bash
groupadd sharedir                     ## 이 그룹에만 읽기/쓰기 허용
mkdir /sharedir
chgrp sharedir /sharedir              ## chown :sharedir /sharedir
usermod -aG sharedir user1

## 특정 그룹에게만 파일 생성을 가능하도록 한다. 
chmod g=rwxs /sharedir
mkdir user1.dir                       ## sharedir그룹으로 상속
touch test1.md
```

### sticky 구성

```bash
## 모든 사용자가 생성이 가능. 자신이 만든 자원 삭제가능
chmod a=rwx,o+t /allsharedir
su - user3
touch user3.md                        ## 자신의 소유권 및 그룹으로 파일생성
mkdir user3.dir
```

### ACL(진도 후 진행)

```bash
setfacl -m u:user1:rwx /aclsharedir/        ## rwx 가능
setfacl -m u:user5:- /aclsharedir/          ## rwx 불가능
setfacl -m g:sharedir:rwx /aclsharedir/     ## rwx 가능     ==  chmod g+s

su - user1
tocuh /aclsharedir/user1.md
mkdir /aclsharedir/user1.dir

su - user5
touch /aclsharedir/user5.md
touch /aclsharedir/user5.dir

getfacl /sharedir/
```

### 연습문제

#### ACL 연습문제

1. 사용자 user5는 /poweracl/ 디렉터리 접근이 가능하다.
2. 사용자 user7는 /poweracl/ 디렉터리에 접근이 불가능하다.
3.  이외 모든 사용자는 /poweracl/ 접근이 불가능하다.

#### 표준 퍼미션 문제

1. 사용자 user2는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
2. 사용자 user1는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
3. /groupbit/ 디렉터리에 접근이 가능한 사용자들은 반드시 groupbit에 가입이 되어 있어야 한다.
4. /groupbit/ 디렉터리에서 생성이 되는 파일 및 디렉터리는 반드시 그룹 권한이 상속이 되어야 한다.
5. /allbit/ 디렉터리에는 모든 사용자가 파일 생성이 가능하지만, 자신이 만든 파일만 제거가 가능하다.


## RPM 저장소 미러 및 설정

### yum
RHEL 8까지 사용하던 패키지 관리자.
  - yellowdog package update manager
  - 파이선 기반으로 작성됨

### dnf(default)
RHEL 9부터 사용하는 패키지 관리자.
  - 기존 yum과 호환성 유지
  - module 기능 추가

### microdnf(container)
  - 컨테이너 이미지 생성시 많이 사용함. 

- dnf, yum의 저장소 정보 위치는, "/etc/yum.repos.d/".
- yum설정 파일은 "/etc/yum.conf", "/etc/yum/".
- dnf로 변경이 되면서 해당 파일은 "/etc/dnf.conf", "/etc/dnf/"으로 변경.
- RHEL 9, Rocky 9, CentOS-9-Stream를 사용하는 경우 __dnf__ 가 기본 사용


GPG확인을 전부 다 끄고 싶은 경우.

```bash
cat /etc/dnf/dnf.conf
[main]
gpgcheck=1 ---> gpgcheck=0
installonly_limit=3
clean_requirements_on_remove=True
best=True
skip_if_unavailable=False 
```

### 연습문제

- node2의 /etc/yum.repos.d/의 모든 파일을 제거.
- 저장소 파일을 아래 주소로 구성.
    + "https://mirror.kakao.com/linux/rocky/9.4/AppStream/x86_64/os/"
    + 내부 저장소가 구성이 되어 있는 경우 "http://10.10.10.1/rpms" 으로 구성
- 구성이 완료가 되면, httpd패키지 검색 및 설치 

## NTP(chronyd)

1. NTP프로토콜 서비스 대몬으로 chronyd를 사용.
2. 앞으로는 systemd-timedated(systemd-timesyncd)서비스로 변경.


```bash
timedatectl
```

ntp서버 동기화를 설정(chronyd). 현재는 두 가지 방식으로 NTP서버와 동기화를 지원.

- systemd-timesyncd 서비스. 현재는 선택사항.
- 구성을 위한 timedatectl명령어
- NTP 클라이언트 설정 파일은 /etc/chrony.conf

```bash
systemctl is-active chronyd
> active
systemctl status chronyd
> 
```

### 임시로 NTPD서버 생성

아래 작업은 node1번에서 수행.

```bash
timedatectl set-ntp false
timedatectl 
> System clock synchronized: no
> NTP service: inactive 

grep -Ev '^#|^$' /etc/chrony.conf 
> pool 2.rocky.pool.ntp.org iburst
> sourcedir /run/chrony-dhcp
> driftfile /var/lib/chrony/
> ...

vi /etc/chrony.conf 
> allow 10.10.10.0/24
> local stratum 2 

firewall-cmd --add-service=ntp
firewall-cmd --runtime-to-permanent
firewall-cmd --list-all

systemctl restart chronyd
```

### NTP클라이언트 설정

아래 작업은 node2번에서 수행.

```bash
rpm -qa chrony
dnf install chrony
systemctl enable --now chronyd

timedatectl
> System clock synchronized: yes 
> NTP service: active
chronyc sources
> ^* 121.162.54.1                  3   6   377    50   -252us[-2293us] +/-   32ms                                              

vi /etc/chrony.conf
> pool ~~~~
> server 10.10.10.1 iburst          ## NTP와 통신이 가능한 상태면 빠르게 ntp동기화

systemctl restart chronyd

timedatectl set-ntp true
chronyc sources
> ^* 10.10.10.1                    4   6     7     0  -4124ns[-4199us] +/- 9941us
```


### 연습문제

- node1 ntp서버를 아래 서버로 구성한다.
  + asia.pool.ntp.org
- node2 ntp서버를 아래 서버로 구성한다.
  + 10.10.10.1
- ntp서비스는 재부팅 이후에도 동작이 되어야한다.


## 종합문제

__DAY 1/2__ 에 수행한 작업 내용 기반으로 다음과 같이 서버구성을 수행한다.

1. 하이퍼바이저에 "node3"를 새로 구성한다. 
2. 가상머신에 설치되는 로키 리눅스 버전은 9.3혹은 9.4로 구성한다.
3. 설치가 된 서버에 아래와 같이 작업을 수행한다.
4. 다음과 같이 사용자 및 그룹 구성.

|그룹이름  |사용자 이름 |ID값       |
|---------|------------|-----------|
| sharegrp|user1,user2 |GID: 10000 | 
| datagrp |            |GID: 11000 |
| devel   |user3       |           |
| infra   |user4       |           |
| cloud   |user5       |           |


5. 랩에서 사용할 사용자의 쉘 구성
  - user1, bash
  - user2, 쉘 사용 금지 혹은 로그인 불가능 == nologin
  - user3, csh 
  - user4, tcsh
  - user5, fish

6. 기존에 설치 된 웹 서버 패키지가 있는 경우 제거.
7. node3에 httpd서비스 설치 후 포트를 변경.
8. SELinux는 무조건 사용.
9. semanage명령어가 없는 경우 올바르게 동작 하도록 패키지 설치.
10. 포트번호는 8723/tcp로 변경 및 설정.
  - /etc/http/conf/httpd.conf
11. /var/www/html/index.html파일에서 "Hello Httpd Node3"메세지 출력.
12. 이 페이지는 반드시 외부에서 접근이 가능해야 됨.
13. 서비스는 리부팅 이후에도 반드시 시작 및 부트업이 되어야 함.
14. 사용자 testuser3, testuser4를 생성한다. 암호는 rockylinux으로 한다.
15. 각 사용자에 "Hello hacker world this is 10 messages"메세지가 출력 되도록 한다.
16. 위의 매세지는 매 10분마다 출력되게 한다.
17. "/usr/share/doc"에서 "GNU"라는 대문자 단어만 찾아서 /root/materials/GNU.txt파일에 저장한다.
18. 다음 디렉터리를 압축해서 /tmp에 보관.
  - /usr/share/doc, bzip, doc.tar.bz2
  - /usr/local, xz, local.tar.xz
  - /var/log, gzip, log.tar.gz

20. 사용자 user1/2/3/4/5를 생성. 없으면 사용자 구성. 비밀번호는 rockylinux으로 설정.
  + 각 사용자 홈 디렉터리에 README.txt파일이 있어야 됨.
  + 각 README.txt파일은 올바르게 소유권 및 퍼미션 구성이 되어 있어야 됨.
21. /tmp/user1, user2, user3, user4, user5 백업 디렉터리 생성.
22. 각각 사용자가 사용하고 있는 모든 파일 및 디렉터리를 각각 백업 디렉터리에 복사.
23. 복사된 백업 디렉터리 내용은 gzip로 압축.
24. 스크립트 파일 이름을 backup_user.sh으로 생성.
  + 이 스크립트는 사용자 user5를 백업한다.
  + user5사용자만 xz파일로 압축한다.
  + 백업 위치는 /opt/backup-user/user5
  + 모든 작업은 스크립트로 동작한다.
  + 파일 압축도 스크립트로 진행한다.

25. 노드 3번에 eth1장치를 추가 후 아래와 같은 작업 수행.
  - 이미 구성이 된 프로파일(profile)은 제거 후 진행.
  - 인터페이스 이름은 eth1.
    + 아이피 주소는 10.10.10.3으로 추가.
    + 넷마스크는 255.255.255.0으로 설정.
      * 이 부분은 비트(cidr)로 처리해야 됨
    + 게이트웨이는 없음.
    + 도메인 정보는 없음.
  - 리부팅 이후에도 정보는 계속 남아 있어야 됨.
26. 사용자 user2는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
27. 사용자 user1는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
28. /groupbit/ 디렉터리에 접근이 가능한 사용자들은 반드시 groupbit에 가입이 되어 있어야 한다.
29. /groupbit/ 디렉터리에서 생성이 되는 파일 및 디렉터리는 반드시 그룹 권한이 상속이 되어야 한다.
30. /allbit/ 디렉터리에는 모든 사용자가 파일 생성이 가능하지만, 자신이 만든 파일만 제거가 가능하다.
31. node3의 /etc/yum.repos.d/의 모든 파일을 제거.
  - 저장소 파일을 아래 주소로 구성.
    + http://10.10.10.1/rpms/
  - 구성이 완료가 되면, vsftpd패키지 검색 및 설치 
32. node3 ntp서버를 아래 서버로 구성한다.
  - 10.10.10.1
  - ntp서비스는 재부팅 이후에도 동작이 되어야한다.



## Q/A

> nmtui로 vlan이나 본딩 구성 시에도 아까 실습으로 보여주신 이더넷 프로파일이랑 동일하게 작업하면 되나요?
아니면 추가로 설정이 필요한 항목이 있을까요??

넵.다만 주의할 부분이 있음. 

1. nmtui는 세부 설정에서 지원이 안되는 부분이 있을수 도 있습니다. 없는 경우, cli로 처리.
2. bond장치는 지원은 하고 있음. 레드햇 9부터는 teamd를 deprecation으로 선언.
3. 2개 이상의 장치를 관리 및 사용을 하고 싶은 경우, teamd를 권장을 함.


# DAY 3

## 시작 전 랩 설정

```bash

man ssh-keygen
man -k ed25519


ssh-keygen -t ed25519 -N '' -f ~/.ssh/id_ed25519  
ls -l ~/.ssh/
> id_ed25519  
> id_ed25519.pub
ssh-copy-id root@10.10.10.2
ssh-copy-id root@10.10.10.3
vi /etc/hosts
> 10.10.10.1 node1.example.com
> 10.10.10.2 node2.example.com
> 10.10.10.3 node3.example.com
scp /etc/hosts root@node1:/etc/hosts
scp /etc/hosts root@node2:/etc/hosts
scp /etc/hosts root@node3:/etc/hosts
```

## 부팅

리눅스 커널은 별도로 __"안전모드"__ 가 존재하지 않음. 레드햇 계열의 배포판 커널은 __rescue__ 커널 이미지가 별도로 존재.

resuce를 사용하는 이유는, 부팅을 하다가 특정한 이유때문에, 예를 들어서 커널 모듈이 인식이 되지마자, 부팅이 행이 걸리던가 혹은 특정 서비스에서 커널 문제가 발생하는 경우 사용.

레스큐 모드를 사용하면, 윈도우와 동일하게 기본 모듈 드라이버로 실행이 됨.

- vmlinuz: 작은커널 이미지 
  + 현재 레드햇은 더 이상 vmlinuz사용하지 않음.
- bzimage: 큰 커널 이미지
  + initramfs-0-rescue-215e6c7df4fb48cfb13f6f97d5fadf82.img
  + initramfs-5.14.0-427.13.1.el9_4.x86_64.img

램 디스크에는 분기점 옵션이 있음. 아래 두 링크를 참조하여 기능과 역할 확인.

1. https://www.man7.org/linux/man-pages/man7/dracut.cmdline.7.html
2. https://www.kernel.org/doc/Documentation/blockdev/ramdisk.txt

```bash
linux rd.break
      rd.debug
      rd.meminfo
```


linux: grub이나 혹은 systemd-bootrec에서 사용하는 옵션.
linux16: lilo 혹은 구버전 grub에서 사용한 옵션.

```bash 
linux ~~~~ rd.break
switch_root# 

## 메모리에서 리눅스 커널 기반으로 부팅이 된 상태.
## initramfs를 통해서 램 디스크 리눅스에서 사용할 커널 모듈(드라이버)를 제공.

ls -l /lib/modules/

## 명령어가 제한이 되어 있음.

df (X)
lsblk (X)

mount | grep sysroot
> /sysroot option: ro
mount -oremount,rw /sysroot
mount | grep sysroot
> /sysroot option: rw

#
# chroot
#

chroot /sysroot/
crt> echo centos | passwd --stdin root
crt> touch /.autorelabel                      ## SELinux에게 레이블링 요청
crt> exit
crt> exit

loging: root
password: centos
```

### 연습문제

node1/2번에 루트 비밀번호를 "centos"로 변경. 단, 조건은 ramdisk에서 변경해야 됨.


## 스왑

Rocky Linux 9버전부터 다음과 같이 스왑이 변경이 되었음.

1. general swap(fileswap, blockswap)
2. RAM swap(zram)

### 일반 스왑

말 그대로 파일이나 혹은 블록 장치로 구성된 페이징 장치. 대다수 리눅스 계열은 블록 장치 기반으로 스왑을 구성.

```bash
PAGE(4K)

+--------------------+
|   MEMROY BLOCK     | ---> [slot memory] ---> CPU CACHE ---> <1/2/3/4> ---> CPU 
+--------------------+                           [SRAM]
        1GiB
         |
         |  유효도가 낮은 녀석
    <paging down>
         |
         |
         v
+--------------------+
|    MEMORY SWAP     | block, file
+--------------------+
```

1. fdisk: MBR전용(Rocky Linux 8버전까지)
2. gdisk: GPT전용

Rocky Linux 9부터는 fdisk에서 GPT도 같이 지원 함.


### 블록 기반

```bash
cfdisk /dev/sdb
fdisk -l /dev/sdb       ## MBR
gdisk -l /dev/sdb       ## GPT

mkswap                  ## 특정 블록 및 파티션에 서명
mkswap /dev/sdb3
dnf install hexedit -y
hexedit /dev/sdb3

swapon -s
> /dev/dm-1                               partition
swapon /dev/sdb3
swapon -s 
> /dev/dm-1
> /dev/sdb3

swapoff /dev/dm-1
swapoff /dev/sdb3
swapon -s
```

### 파일기반

```bash
#
# 확장자는 마음대로 정의 하셔도 상관 없습니다. :)
# 

dd if=/dev/zero of=/tempswap.img bs=500M count=1
mkswap /tempswap.img
chmod 0600 /tempswap.img 
swapon /tempswap.img
swapon -s
> /tempswap.img
swapon /dev/sdb3

swapon -s
> /dev/sdb3, parition
> /tempswap.img, file

vi /etc/fstab
> /dev/sdb3       swap    swap    defaults   0 0
> /tempswap.img   none    swap    defaults   0 0

swapoff -a
swapon -a
swpaon -s
> /dev/sdb3, parition
> /tempswap.img, file

systemctl daemon-reload
reboot
```
### 연습문제

nodeb서버에 다음과 같이 블록 장치를 추가 및 파티션 생성한다.

1. /dev/sdb블록장치를 하이퍼바이저를 통해서 추가.
2. 첫 번째 파티션은 일반 리눅스 파티션으로 생성.
3. 두 번째 파티션은 LMV2 파티션으로 생성.
4. 세 번째 파티션은 swap 파티션으로 생성.
5. 파일 기반으로 500메가짜리 스왑 생성 및 확인.
6. 블록 스왑 구성 후 올바르게 동작이 되는지 확인.
7. 파일 및 블록 스왑은 리부팅 이후에도 동작 해야됨.


## LVM2

현재 리눅스 배포판은 두 가지 파일 시스템으로 나누어 졌음.

1. btrfs(성능은 제일 낮음, 관리 기능으 우수)
2. xfs(성능은 제일 우수, 관리 기능이 부족)
3. ext4(성능도 모호, 관리 기능도 모호)

레드햇 계열 배포판은 xfs+LVM2기반으로 구성. 사전 지식으로 다음과 같은 부분이 필요.

1. 파티션 관리 기능(cfdisk)
2. 포멧(mkfs.xfs, mkfs.vfat, mkfs.ext3/4)
3. mount명령어
4. /etc/fstab

### 생성 순서

1. 파티션을 생성.
2. LVM에서 사용하는 PV/VG/LV를 구성.
3. 포멧.
4. 마운트 및 영구적 마운트 설정.


```bash
cfdisk /dev/sdb
fdisk -l | grep /dev/sdb  
> /dev/sdb1     2048 2099199 2097152   1G Linux filesystem                                                                    
> /dev/sdb2  2099200 4196351 2097152   1G Linux LVM                                                                            
> /dev/sdb3  4196352 6293503 2097152   1G Linux swap

## LVM2메타정보 생성 및 구성.

pvcreate /dev/sdb2                ## 파티션 혹은 블록 장치에 LVM장치 명시
vgcreate testvg /dev/sdb2         ## 디스크 어딘가에 메타정보를 저장

pvs                               ## pv scan
vgs                               ## vg scan

## 블록장치를 생성.

vgdisplay testvg                  ## testvg에 대한 메타정보 조회

> PE Size: 4Mib --> power(제곱근)
> Free  PE / Size       255 / 1020.00 MiB
                        ---   ------
                         \      \
                          \      `--> 크기(-L)
                           `---> 갯수(-l)
#
# 4Mib = 1 PE = 4MiB
#
lvcreate -n testlv-pe-10c -l 10 testvg
lvcreate -n testlv-pe-20c -l 20 testvg 

lvcreate -n testlv-sz-100m -L 100M testvg 

man lvcreate
> -l
> -L
lvcreate --help
```

고객의 요청.

나는 "PE Size: 16Mib"를 원해요.

```bash
pvcreate /dev/sdb1                ## 파티션 혹은 블록 장치에 LVM장치 명시
vgcreate testvg-pe /dev/sdb1         ## 디스크 어딘가에 메타정보를 저장

vgcreate -s 16m testvg-pe /dev/sdb1
        ----
        \
         `---> physicalextentsize
vgdisplay testvg-pe
> PE Size               16.00 MiB
lvcreate -n testlv-pe-20c -l 10 testvg-pe

## 만약, 이름 잘못 넣어서 눈물이 나오려고 할때!!

lvrename testvg-pe testlv-pe-20c testlv-pe-10c  

lvs
> testlv-pe-10c  

lvcreate -l 100%Free -n testlv-full testvg   
lvcreate -l 100%Free -n testlv-full testvg-pe


lvdisplay | grep "LV Path"

mkfs.ext3 /dev/testvg/testlv-pe-10c
mkfs.ext4 /dev/testvg/testlv-pe-20c
blkid

mkfs.vfat /dev/testvg/testlv-sz-100m
mkfs.xfs /dev/testvg-pe/testlv-pe-10c
blkid

> LV Path                /dev/testvg/testlv-pe-10c
> LV Path                /dev/testvg/testlv-pe-20c
> LV Path                /dev/testvg/testlv-sz-100m
> LV Path                /dev/testvg/testlv-full  # mkfs.xfs
> LV Path                /dev/testvg-pe/testlv-pe-10c
> LV Path                /dev/testvg-pe/testlv-full  # mkfs.xfs

mkfs.xfs /dev/testvg-pe/testlv-full 
mkfs.xfs /dev/testvg/testlv-full

mkdir -p /mnt/testlv-pe-10c
mkdir -p /mnt/testvg/testlv-pe-20c
mkdir -p /mnt/testlv-sz-100m
mkdir -p /mnt/testlv-full 
mkdir -p /mnt/testlv-pe-10c
mkdir -p /mnt/testlv-full 


mount /dev/testvg/testlv-pe-10c /mnt/testlv-pe-10c
...

```

LVM2 볼륨을 구성하기 위해서 아래와 같이 순서대로 작업 진행.

| 명령어 | 설명   |
|--------|--------|
|1 pvcreate(pv)|물리적 장치 시그네처 생성. 보통 PV라고 이야기함 |
|2 vgcreate(vg)|볼륨그룹 장치 생성. 1개 이상의 PV를 VG가 가지고 있음 |
|3 lvcreate(lv)    |논리적 장치 생성. 최종적으로 사용자가 생성하는 장치 |

앞에서 사용한 약어는 다음과 같은 뜻을 가지고 있음.

- PV: Physical Volume
- VG: Volume Group
- LV: Logical Volume

순서대로 명령어를 사용하면 아래와 같이 사용해야 됨.

1. pvcreate
2. vgcreate
3. lvcreate

일반적으로, 이 순서로 장치 구성 및 생성. 

1. vgcreate
2. lvcreate

LVM2를 구성하기 위해서 가급적으면 사용할 파티션 생성 후, LVM2를 구성을 권장.

간단하게 LVM2에 새로운 디스크를 생성한다.

```bash
cfdisk /dev/sdb
> /dev/sdb2                  ## 새로 파티션 하나 생성. 모든 공간 사용
> 파티션 형식으로 Linux LVM로 변경
lsblk
fdisk -l
pvcreate /dev/sdb2           ## PV로 사용하겠다고 싸인표시
pvs
vgcreate vgtest /dev/sdb2    ## /dev/sdb2의 PV를 VG에 사용 선언
vgs
lvcreate -n lvtest00    -l   100%Free       vgtest
            --------         --------      --------
            디스크 이름         \           VG이름
                                 \
                                  `--> 모든 PE(extend)개수를 다 사용
lvs
lvdisplay
> /dev/vgtest/lvtest00
mkfs.xfs /dev/vgtest/lvtest00               ## 파일 시스템 생성(슈퍼블럭), VFS에서 마운트를 못함
mkdir -p /mnt/test
mount /dev/vgtest/lvtest00 /mnt/test

df
> /dev/mapper/vgtest-lvtest00  10369024 105404       580 1% /mnt/test
umount /mnt/test

mkdir -p /mnt/lvtest00
vi /etc/fstab
> /dev/vgtest/lvtest00   /mnt/lvtest00    xfs     defaults 0 0
mount -a
df
> /dev/mapper/vgtest-lvtest00  10369024 105404       580 1% /mnt/lvtest00

systemctl daemon-reload
dracut -f

dd if=/dev/zero of=/mnt/lvtest00/dummy.data bs=1G 
>dd: error writing '/mnt/lvtest00/dummy.data': No space left on device
>10+0 records in
>9+0 records out
>10509352960 bytes (11 GB, 9.8 GiB) copied, 31.636 s, 332 MB/s

## 명령어 요약
cfdisk | fdisk | gdisk 
pvcreate /dev/sdb2
vgcreate /dev/sdb2 hellovg
lvcreate -l 100%Free -n hellolv hellovg
## -t: 
## -L: 디스크 크기
## -l: 익스텐드(extend) 개수
```

- pvs, vgs, lvs: 간단하게 PV상태 확인
- pv/vg/lvdisplay: 자세하게 PV상태확인

### lvm2기반으로 swap생성

```bash
cfdisk /dev/sdc
> 1G 파티션 생성
> 타입은 LVM으로 변경
pvcreate /dev/sdc1
vgcreate testswap /dev/sdc1 
lvcreate -n lvswap -L 500M testswap

mkswap /dev/testswap/lvswap
vi /etc/fstab
/dev/testswap/lvswap     swap    swap   defaults  0   0
swapon -a
swapon -s
reboot
```

### LVM2 리사이즈

특정 VG 및 LV 디스크 공간이 부족할때 사용.

```bash
vgs
>VG       #PV #LV #SN Attr   VSize    VFree
>rl         1   3   0 wz--n-  125.41g      0
>testswap   1   1   0 wz--n- 1020.00m 520.00m
>vgtest     1   1   0 wz--n-   <9.90g      0

fdisk /dev/sdc
>2기가 파티션 추가 생성
>LVM파티션으로 수정

# pvcreate /dev/sdc2
vgextend vgtest /dev/sdc2
vgs                                           ## Free영역이 늘어 났는지 확인
# cp -a /usr/share/doc /mnt/lvtest00          ## 테스트 명령어
> No space left on device 
lvdisplay
lvextend -r -L +500M /dev/vgtest/lvtest00     ## -r옵션은 파일시스템도 자동으로 확장
df
reboot

xfs_growfs /mnt/lvtest00
resize2fs /dev/testvg/testlv 

```

### PE크기 변경 및 LVM 생성

```bash
fdisk /dev/sdd
> 3기가 파티션
> LVM으로 형식 변경
fdisk -l /dev/sdd
vgcreate -s 4m  resizevg /dev/sdd1
         -s 16m
vgdisplay resizevg
> PE Size               16.00 MiB
lvcreate -l 50 -n resizeinglv resizevg
mkfs.ext4 /dev/resizevg/resizeinglv
vi /etc/fstab
>/dev/resizevg/resizeinglv   /mnt/ext4    ext4    defaults 0 0
mount -a
```

### Stratis

XFS기반으로 Pool기능을 구현. XFS에서는 Pool기능이 없어서, Stratis기반으로 Pool기반의 Filesystem를 구성. 상대적으로 LVM2보다 가볍고 편하게 디스크 관리가 가능.

만약, XFS의 Stratis 파일 시스템 풀링 싫으면, btrfs의 네이티브 파일 시스템 풀링 기능을 사용하여도 됨. 하지만, RHEL계열의 배포판에서는 대다수가 btrfs를 지원 안함.

- xfs, pool(x)
- btrfs, pool
- zfs, Oracle (x)
- jfs, IBM AIX (x)

```bash
cfdisk /dev/sdd
> 3G기가 파티션
> 리눅스 파일 시스템
fdisk -l /dev/sdd
> /dev/sdd2  6293504 12584959 6291456   3G Linux filesystem
dnf search stratis
dnf install stratisd stratis-cli -y
systemctl enable --now stratisd
stratis pool list
stratis pool create pool1 /dev/sdd2
stratis filesystem create pool1 xfs_disk
mkdir -p /mnt/test
mount /dev/stratis/pool1/xfs_disk /mnt/test
blkid
> /dev/mapper/stratis-1-709d22ce20b14e67aaf31779e00357b3-thin-fs-ccbcbf2b9942479cbc4cec628b8f9084: UUID="ccbcbf2b-9942-479c-bc4c-ec628b8f9084" TYPE="xfs"
```

VG에서 PV제거하기(제외)

```bash
vgdisplay testvg
pvs
> PV가 어떤 VG에 포함이 되어 있는지
vgremove /dev/sdb2 testvg           ## testvg에서 sdb2 PV를 제거
vgs
pvs
vgextend vgtest /dev/sdb2
```


연습문제
---
지식확인 문제

## 스토리지

디스크 /dev/sdb에 다음처럼 파티션을 구성 및 생성한다.
  - 1기가 크기의 스왑 파티션을 생성한다.
  - 1기가 크기의 LVM디스크를 생성한다.
  - 불륨그룹의 이름은 testvg이며, 논리디스크 이름은 testlv이다.
    + 디스크 크기는 testvg 영역을 전부 사용한다.
  - 해당 디스크는 반드시 /mnt/testlv에 연결 및 구성이 되어야한다.
    + dd if=/dev/zero of=/mnt/testlv/dummy.data count=1 bs=1G 실행
  - 스왑 및 디스크 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

LVM기반으로 스왑 디스크를 생성한다.
  - SWAP크기는 2기가 이며, LVM에 lvswap이름으로 논리 디스크를 구성한다.
  - 해당 스왑은 testvg영역에서 생성이 된다.
  - 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

볼륨그룹 공간 확장
  - /mnt/testlv에 공간이 부족한 경우, 공간을 확장한다. 
  - 확장 시, 사용하는 공간 크기는 5기가를 사용한다.
  - 기존 파일 시스템에 손상이 없이 파일 시스템을 확장한다.
  - 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

새로운 LVM디스크를 구성한다.
  - 익스텐드 크기는 8메가로 구성한다.
  - 새로운 디스크의 이름은 extendlv으로 구성한다.
  - 불륨 그룹 이름은 extendvg로 구성한다.
  - 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

Pool 파일 시스템을 구성한다.
  - 디스크 전체를 Pool로 구성한다.
  - Pool의 이름은 pool-storage으로 한다.
  - 파일 시스템 이름은 data-filesystem으로 설정한다
  - 리부팅 이후에도 정상적으로 연결 및 동작이 되어야 한다.

### container

docker는 더 이상 사용하지 않음. docker가 미란티스라는 회사에 인수가 된 이후, 개발 방향을 변경.

docker는 도커 하위 계층인 containerd를 분리. 현재 쿠버네티스 및 CNCF 표준 런타임. 
쿠버네티스는 CRI표준 기반의 CRI-O런타임 사용. containerd, cri-docker를 사용할 수 도 있음.

학습 시, 권장하는 방법은 docker가 아닌, podman기반으로 학습. 기존 도커에서 사용하던 명령어 및 컨테이너 이미지 파일은 현재 OCI사양에서 표준 이미지 및 명령어로 채택. 현재 레드햇 리눅스 및 다른 상용 배포판 그리고 커뮤니티 배포판은 docker가 아닌 podman으로 권장. 

- podman
- buildah
- skopeo

systemd에서는 컨테이너 기반으로 서비스 혹은 애플리케이션을 실행 할 수 있음. 

podman.service: API 서비스 대몬

```bash
dnf search podman
dnf install podman -y
adduser containeruser
echo rocky | passwd --stdin containeruser
ssh containeruser@localhost
cu$> podman login -u <ID> -p <PASSWD> <URL>      ## 로그인 단계
cu$> podman search httpd                           ## 이미지 검색
cu$> podman pull quay.io/centos7/httpd-24-centos7:latest
cu$> podman run -d -p8080:8080 --name container-web quay.io/centos7/httpd-24-centos7:latest
## -p: 외부포트:컨테이너 포트
## -d: deatach, 백-그라운드 실행
## --name: 컨테이너가 생성시 사용하는 이름
cu$> podman stop --all       ## 모든 컨테이너 동작 중지
cu$> podman rm --all          ## 모든 컨테이너 삭제
cu$> podman ps
cu$> curl localhost:8080
cu$> podman generate systemd --new --files --name container-web
cu$> man -k podman-
cu$> man podman-generate-systemd               ## 무조건 맨 페이지 참고
      --> Installation of generated systemd unit files.
cu$> mkdir -p ~/.config/systemd/user
cu$> cp container-container-web.service ~/.config/systemd/user
cu$> systemctl daemon-reload --user
cu$> systemctl enable --now container-web --user
root#> loginctl enable-linger containeruser
cu$> systemctl status container-web --user
cu$> curl localhost:8080
```
 
```bash

## 사용자 containeruser에서 진행

wget https://raw.githubusercontent.com/tangt64/training_memos/main/opensource/linux-101/materials/Containerfile

## Dockerfile에서 현재는 Containerfile로 변경.

podman build . -t web-container
buildah bud -f <FILENAME>          ## dnf install buildah, 선택사항 :)
podman images
mkdir htdocs/
echo "hello systemd service container" > htdocs/index.html

## -Z: SELinux Context 상속 옵션

podman run -d --name new-web-container -v /home/containeruser/htdocs/:/var/www/html/:Z -p 8081:80 localhost/web-container
curl http://localhost:8081
>hello systemd service container
```

연습문제
---
- 컨테이너 이미지를 빌드한다. 컨테이너 파일은 github에서 내려받기한다.
- 이미지 이름은 hello-www으로 명명한다.
- 컨테이너가 실행이 되면 포트, 8082로 접근이 되어야 한다. 
  + 만약, 접근이 안되는 경우 트러블 슈팅을 진행한다. 
- 컨테이너는 htdocs2디렉터리에 있는 index.html파일에 접근이 가능해야 한다.
  + index.html파일에서는 "hello www service"라는 텍스트를 가지고 있어야 한다.
  + /var/www/html/으로 바인딩이 되어야 한다. 
- 구성된 컨테이너는 systemd기반으로 서비스 구성한다.
  + 리부팅 이후에도 정상적으로 동작이 되어야 됨.
  + 사용자가 로그아웃을 하여도 서비스는 계속 동작이 되어야 됨. 


### tuned

__커널 파라메타__ 를 프로파일 기반으로자 동으로 조절 해주는 도구. 

```bash
dnf install tuned -y

systemctl enable --now tuned
tuned-adm profile

tuned-adm profile desktop            ## 수동으로 변경
tuned-adm active                     ## 현재 사용중인 프로파일 확인
tuned-adm recommend                  ## 알아서 프로파일 선택
tuend-adm auto_profile
```

연습문제
---
- 프로파일 AWS 프로파일로 변경한다.
- tuned에서 권장하는 프로파일를 사용한다.

### autofs

특정 디렉터리를 NFS와 같은 공유 파일 시스템을 통해서 자동적으로 연결 및 구성.

1. 최소 NFS서버나 혹은 samba서버가 있어야 됨.
2. 클라이언트 서버에는 autofs설치가 가능해야 함. 


서버(node1)
---

```bash
dnf install nfs-utils
systemctl enable --now nfs-server
setenforce 0
mkdir -p /srv/nfs/nfs-user1
mkdir -p /srv/nfs/nfs-user2
mkdir -p /srv/nfs/direct-user
ls -l /etc/exports
vi /etc/exports
/srv/nfs/direct-user *(rw,sync)      ## 다이렉트
/srv/nfs/nfs-user1   *(rw,sync)      ## 다이렉트 
/srv/nfs/nfs-user2   *(rw,sync)      ## 다이렉트
/srv/nfs/            *(rw,sync)      ## 인-다이렉트
exportfs -avrs
systemctl stop firewalld
```

클라이언트(node2)
---

```bash
dnf install nfs-utils -y
adduser -M nfs-user1                ## 사용자 홈 디렉터리 생성하지 않음.
adduser -M nfs-user2

## -------------------------

showmount -e 192.168.122.247        ## 서버 아이피, node1번 아이피 입력 해주세요.
exporting *:/srv/nfs
exporting *:/srv/nfs/nfs-user2
exporting *:/srv/nfs/nfs-user1

dnf install autofs -y
cd /etc/auto.master.d/

## in-direct 구성

vi mappinguser.autofs
/home/               /etc/auto.mappinguser

vi /etc/auto.mappinguser
*       -rw,sync       192.168.122.247:/srv/nfs/&
systemctl restart autofs

## direct 구성
vi direct.autofs
/-               /etc/auto.direct
vi /etc/auto.direct
/home/direct-user       -rw,sync       192.168.122.247:/srv/nfs/direct-user


terminal2] journalctl -lf -u autofs.service
```

연습문제
---


# 메모
- 특정 그룹에 어떤 사용자가 포함이 되어 있는지?
  - grep wheel 
  - 이는 'lid'명령어로 확인이 가능
- SELINUX/CRONTAB

## 옵션 설명, firewalld

__runtime-to-permanent:__ 현재 firewalld에 등록되어 있는 정책 내용을 그대로 디스크에 영구적으로 저장. 리부팅 이후에도 다시 재적용.
__permanent:__ "--permanent"옵션이 들어간 "firewall-cmd"정책만 디스크에 영구적으로 저장.