# 리눅스 어드민 기본 과정

가상서버 2대 기반으로 랩을 진행 합니다.

## 랩에서 사용하는 가상머신 사양
* ISO 내려받기 주소[링크](https://download.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9.3-x86_64-minimal.iso)
* 하이퍼브이[링크](https://learn.microsoft.com/ko-kr/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)
  - windows 10/11 pro
* VirtualBox, VMware Player/Workstation
  - AMD CPU에서는 비권장(특히, VBox)
  - Fusion, VMware Player

## 강의실 정책
- 쉬는시간: 매 시간 50분 수업 후 15분 휴식
- 점심시간: 11시 40분 ~ 12시 50분(1시간 20분, 실제시작은 보통 1시)


```bash
vCPU: 2개(I3,I5), 사양이 부족하시면 1개로도 가능
vMEM: 2048MiB+ 
vDISK: 
  Node 1: OS=20GiB
          /dev/vda: OS, 20GiB  ## 따라오기 어려우시면, 일단 OS만 설치!!
          /dev/vdb: data, 2GiB
          /dev/vdc: data, 2GiB
          /dev/vdd: data, 3GiB
          HOSTNAME: node1.example.com
  Node 2: OS=20GiB
          /dev/vda: OS, 20GiB
          /dev/vdb: data, 2GiB
          /dev/vdc: data, 2GiB
          /dev/vdd: data, 3GiB          
          HOSTNAME: node2.example.com
```

# DAY 1

## 사용자 관리

### 사용자 비밀번호

1. adduser, GNU계열의 사용자 추가 명령어
2. useradd, BSD계열의 사용자 추가 명령어

```bash
whereis adduser(default)
whereis useradd(link, symbolic)
```

### 새로 추가된 옵션(systemd, btrfs, selinux)
---
1. --badname: 사용자 이름 형식 확인하지 않음.
2. --btrfs-subvolume-home: 사용자 홈 디렉터리를 서브볼륨의 구성.(레드햇 계열에서 사용 불가능)
3. --password: 사용자 패스워드 설정. 대신, openssl, mkpasswd를 통해서 사용이 가능. 
4. --root: chroot기능. 사용자를 가상의 네임스페이스 영역(컨테이너)에서 사용이 가능.

"2", "3", "4"번은 앞으로 많이 사용할 옵션.

```bash
                         groupmod
                   .---> usermod
                  /
             /etc/group
adduser ---> /etc/passwd <--- [systemd] --- <logind>
            ------------
              \
               `---> /etc/gshadow
                     /etc/shadow

getent ---> /etc/passwd
          > /etc/group
          > /etc/hosts

```

### 사용자 추가

```bash
## 1
adduser testuser0
passwd testuser0

## 2
adduser testuser1
passwd testuser1
echo rocky | passwd --stdin testuser1

## 3
dnf provides mkpasswd 
> mkpasswd
dnf install mkpasswd -y
mkpasswd -m sha-512
adduser testuser2 --password $6$U9eL0Hyz2aQQPkg6$7svxabfdis20VFAorDh99uTwqa.EjblifybBrYukqjUXC7AaoVLKsceVtSgMd7Dx1eIuHYIhJIJQ.HsktTq651
```

### 사용자 생성 확인

사용자 비밀번호를 콘솔에서 입력 후 접근하기 위해서 "sshpass"패키지 설치를 권장.

```bash
su - <USER>                                                     ## 비밀번호 없이 사용자 전환이 가능. 비밀번호 확인이 불가능.
ssh user1@node1.example.com                                     ## 비밀번호 입력 후 로그인이 되어야함.
> <PASSWORD>

dnf install sshpass -y
ssh testuser[1-2]@localhost
sshpass -p rocky ssh testuser1@localhost id
> uid=1001(testuser2) gid=1001(testuser2)
ssh user1@localhost
sshpass -p rocky ssh testuser2@localhost id
> uid=1001(testuser2) gid=1001(testuser2)
```


### 그룹 생성 및 사용자 추가

사용자 그룹 생성 시 사용하는 명령어는 아래와 같다.
- groupadd
- usermod
- groupmod

특정 사용자를, 특정 그룹에 편입 시키는 방법.
- 사용자 UID 그룹 GID 1000번으로 시작(systemd이후로 모든 리눅스는 1000번 이후로 사용)
- 일반적으로 그룹만 시스템에 추가하는 경우 GID를 1만번(10000) 이후부터 사용

```bash
/etc/passwd
0
  
499     > system account: kernel 
          service account: httpd, ftpd

999

1000    > normal user account

/etc/group
10000   > group GID additional range

```

```bash
groupadd testgroup -g 10000
usermod -aG testgroup testuser1
usermod -aG testgroup testuser2

grep testgroup /etc/group 
> testgroup:x:1003:testuser1,testuser2
  ---------        -------------------
  그룹이름               사용자들

groups testuser1
> testuser1 : testuser1 testgroup
              --------- ---------
              주 그룹    보조 그룹
```

### 사용자 확인

리눅스 사용자 확인을 위해서 보통 사용하는 방식이 'id', 'grep testuser1 /etc/passwd'와 같은 방법으로 한다.
앞으로 사용할 __표준 리눅스(LSB Linux)__ 에서는 다음과 같은 방식(getent)으로 사용자 확인을 권장.

```bash
getent
> Get entries from administrative database(/etc/passwd, /etc/group).
> 사용자 정보를 가져오는 명령어.

getent passwd testuser1
> testuser1:x:1002:1002::/home/testuser1:/bin/csh
getent group testgroup
             testuser1
> testgroup:x:1003:testuser1,testuser2
getent host node1.example.com
```

### 쉘 변경

1. usermod(default)
2. chsh(optional package)

```bash
dnf provides chsh
> util-linux-user
dnf install util-linux-user -y
dnf install zsh csh -y

## 쉘 정보를 확인하고 싶은 경우
chsh -l
> /bin/sh
> /bin/bash
> /usr/bin/sh
> /usr/bin/bash
> /usr/bin/zsh
> /bin/zsh
> /bin/csh

chsh -s /bin/zsh testuser2
usermod -s /bin/zsh testuser2
getent passwd testuser2
> testuser2:x:1001:1001::/home/testuser2:/bin/zsh
```

### 사용자 락(lock) 혹은 로그인 금지

특정 사용자가 더 이상 시스템에 로그인을 할 수 없도록 하는 요구사항.

1. 'usermod', 'chsh'로 쉘을 변경.(아내 메세지가 출력이 됨)
2. 'usermod -L'명령어로 사용자 잠금.(안내 메세지가 출력이 되지 않음)

보통 리눅스에서 로그인이 되지 않는 쉘은 다음처럼 구성 및 사용.

1. /usr/bin/false
2. /usr/sbin/nologin(default, 쉘 안내 메세지가 출력)

```bash
## 사용자를 로그인을 하지 못하도록 한다.
usermod -s /usr/sbin/nologin noshelluser
~~usermod -s /usr/sbin/false noshelluser~~
sshpass -p rocky ssh noshelluser@localhost
> This account is currently not available.
> Connection to localhost closed.


## 특정 사용자는 시스템 접근이 되지 않는다.
usermod -L baduser
getent passwd baduser

sshpass -procky ssh baduser@localhost
> Permission denied, please try again.
```

### 연습문제 1

예를 들어서 다음과 같이 사용자 및 그룹 구성.

|그룹이름  |사용자 이름 |ID값       |
|---------|------------|-----------|
| sharegrp|user1,user2 |GID: 10000 | 
| datagrp |            |GID: 11000 |
| devel   |user3       |           |
| infra   |user4       |           |
| cloud   |user5       |           |



```bash
## 먼저 그룹 생성 후 사용자 추가
chsh -l                                                  ## 쉘 목록 확인이 가능
cat /etc/shells                                          ## 쉘 목록 확인이 가능
usermod                                                  ## 계정 정보 변경

groupadd sharegrp -g 10000                               ## -g옵션을 통해서 사용자 그룹 gid값을 변경
groupadd datagrp -g 11000

adduser -u 10000 -G sharegrp -s /usr/bin/tcsh user1      ## UID + GID + SHELL 사용자 생성 
adduser -u 11000 -G datagrp  -s /usr/bin/nologin user2

echo "helloworld" | passwd --stdin user1                 ## 패스워드 설정
echo "helloworld" | passwd --stdin user2                 ## 패스워드 설정

id user1                                                 ## 사용자가 잘 추가가 되었는지 확인
id user2

adduser -G sharegrp user1
adduser -G sharegrp user2
cat /etc/group

## 사용자 추가 후, 그룹 설정

groupadd sharegrp -g 10000
tail -10 /etc/group

id user1

usermod -aG

# a: append
# G: GroupName

usermod -aG sharegrp user1
usermod -aG sharegrp user2
usermod -aG devel user3
usermod -aG infra user4
usermod -aG cloud user5

id user1
id user2
id user3
id user4
id user5
```

### 연습문제 2

랩에서 생성할 사용자 이름.
  - user1, bash
  - user2, 쉘 사용 금지 혹은 로그인 불가능 == nologin
  - user3, csh 
  - user4, tcsh
  - user5, fish

```bash
adduser user1
adduser -s /usr/sbin/nologin user2
adduser -s /usr/bin/csh user3
adduser -s /usr/bin/tcsh user4
adduser -s /usr/bin/fish user5
```

사용자 hacker는 csh를 사용한다.
사용자 twitter는 쉘 접근이 되지 않으며, sharegrp에 보조 그룹으로 가입이 되어있다.
모든 사용자 비밀번호는 명시되어 있는 비밀번호로 설정한다.


일반 사용자에게 쉘 권한을 비부여 하려면 아래와 같이 쉘 설정
  - 사용자가 추가가 되면, 보통은 /etc/passwd에 사용자가 추가
  - RHEL 7/8/9오면서 기본적으로 모든 사용자는 UID/GID 1000:1000으로 시작함

```bash
##
## 무조건 루트에서 작업
##

cat /etc/shells                  ## 모든 쉘 경로가 있음, nologin, false는 없음.

dnf install epel-release -y      ## fish설치하기 위해서 엔터프라이즈 패키지 저장소 설치
dnf install csh fish -y
cat /etc/passwd
adduser user1
echo $?                          ## 명령어 실행값 반환 확인. 0으로 반환이면 문제가 없음.
grep user1 /etc/passwd
adduser -s <SHELL_PATH>          ## chsh -l
adduser -s /usr/sbin/nologin
                                 ## cat /etc/shells
whereis false                    ## 로그인 차단
whereis nologin                  ## 로그인 차단, 권장
dnf install util-linux-user -y
chsh -l
chsh -s /usr/sbin/nologin user3
usermod -s <SHELL> user3         ## LSB(Linux Standard base)에서 권장
vi /etc/passwd
user3:x:1002:1002::/home/user3:/usr/bin/tcsh

userdel -r user3                 ## -r home디렉터리 삭제
userdel -r user2  
userdel user1                    ## rm -rf /home/user1
```
만약 "Creating mailbox file: File exists"메일 박스 오류가 발생하는 경우.
```bash
userdel user1
adduser user1
Creating mailbox file: File exists
rm -f /var/spool/mail/user1
```

### 사용자 정보 수정

1. 사용자 제거

```bash
adduser incorrectuser
userdel -r incorrectuser

getent passwd incorrectuser

echo $?         ## 0: 정상, 1: 비정상
```

2. 사용자 정보 수정

```bash
usermod -u 15000 incorrectuser
getent passwd incorrectuser
> 15000
groupmod -g 15000 incorrectuser
> 15000
usermod --login correctuser incorrectuser
usermod --login correctuser --move-home /home/correctuser incorrectuser 
groupmod --new-name corretuser incorrectuse
mkdir -p /home/correctuser 
usermod --home /home/correctuser correctuser
getent passwd correctuser
> correctuser:x:150000:150000::/home/correctuser:/bin/bash
```

## DNF3/YUM

### dnf, yum 차이점
RHEL 8버전 이후부터는 yum명령어에서 RHEL 9부터는 dnf명령어로 세대 교체가 됨. 
dnf에서는 추가적으로 __module__ 기능을 지원하며, yum에 비해서 실행속도 및 메모리 사용량이 작고 빠름.

명령어 위치 확인.
```bash
whereis dnf
whereis yum
```

1. 저장소 관련(RHEL vs CentOS vs Rocky)

- appstream                                              Rocky Linux 9 - AppStream
- baseos                                                 Rocky Linux 9 - BaseOS
- extras                                                 Rocky Linux 9 - Extras

"appstream"에서 추가된 패키지는 앞서 이야기한 "module package"가 추가가 됨.
```bash
dnf module list
> nginx[1.22]
> nginx[1.24]

dnf info nginx
> 1.20
dnf module install nginx:1.24
```

2. 변경된 명령어 도구(yum-utils)

- yum-config-manager: yum-utils
- dnf config-manager: dnf command(default) 

```bash
rm -f /etc/yum.repos.d/*
ls -l /etc/yum.repos.d/
> N/A 

## 1번
dnf config-manager --add-repo=http://localhost/rpms

## 2번 
dnf install yum-utils
yum-config-manager --add-repo=http://localhost/rpms
> /etc/yum.repos.d/localhost.repo

dnf clean all
dnf search httpd-core

## SELinux에 차단중
setenforce 0 

vi /etc/yum.repos.d/localhost.repo
> [localhost]
> name=created by dnf config-manager from http://localhost
> baseurl=http://localhost
> enabled=1
> gpgcheck=0
dnf install vsftpd -y
```

3. 저장소 구성

```bash
dnf install yum-utils -y
vi ~/.tmux.conf
> set-option -g mouse on
> bind -n WheelUpPane if-shell -F -t = "#{mouse_any_flag}" "send-keys -M" "if -Ft= '#{pane_in_mode}' 'send-keys -M' 'select-pane -t=; copy-mode -e; send-keys -M'"
> bind -n WheelDownPane select-pane -t= \; send-keys -M
tmux
dnf install httpd httpd-core -y
mkdir -p /var/www/html/rpms
rm -f /etc/yum.repos.d/localhost.repo
dnf reposync -p /var/www/html/rpms
dnf install createrepo_c -y
createrepo_c /var/www/html/rpms
systemctl enable --now httpd
```

### 상규님 질문 :)

여러 버전의 RPM파일을 오프라인으로 저장소 형태로 만들고 싶은 경우(dnf기준) 다음과 같이 진행.

```bash
mkdir -p /var/www/html/rpms/9.0
reposync --releasever 9.0 -p /var/www/html/rpms/9.0/
createrepo /var/www/html/rpms/9.0/
mkdir -p /var/www/html/rpms/9.1
reposync --releasever 9.1 -p /var/www/html/rpms/9.1/
createrepo /var/www/html/rpms/9.1/
```


3. 패키지 관리

1. RPM명령어(rpm)

이 명령어는 오프라인 상태에서 사용이 가능. 저장소 없이 사용 가능.
```bash
rpm -qi httpd-core         ## 패키지 정보
rpm -ql httpd-core         ## 파일 목록
rpm -qf /usr/sbin/httpd == dnf provides httpd
rpm -qa httpd
rpm -qa | grep httpd 
rpm -e httpd-core
```

2. dnf/yum 

이 명령어는 오프라인에서 동작하지 않음. disconnected 혹은 폐쇠망에 저장소가 구축이 안되어 있으면 사용이 불가능.

```bash
dnf provides httpd
dnf install httpd
dnf remove httpd
dnf update 
```

### 종합문제(사용자/그룹/저장소/패키지)

완료하시면 화면에, __"done-lab"__ 이라고 챗팅창에 남겨 주세요.

1. 로그인 가능하다.         == 쉘 사용이 가능.
2. 시스템 접근이 불가능하다. == 쉘 사용이 불가능.

- 사용자 www-hacker, www-user, data-user 그리고 db-user를 생성한다.
- 모든 사용자는 비밀번호를 rockylinuxworld라고 설정한다.
- 사용자 www-hacker는 웹 서비스(httpd)에 접근은 가능하나, 시스템에 접근은 불가능하다.
  - apache라는 그룹에 포함이 된다.
  - www-hacker는 반드시 보조그룹으로 apache에 가입된다.
- www-user,data-user는 secure-data그룹에 포함이 된다.
  - 각 사용자는 tcsh를 통해서 시스템에 접근이 가능하다.
  - 그룹 secure-data가 없는 경우, 사용이 가능하도록 생성한다.
  - GID번호를 13000번으로 설정한다.
- db-user는 wheel그룹에 포함이 되며, 시스템에 로그인이 가능하다.
- 각각 사용자를 ssh로 접근 후 "id"명령어 실행한다.
- 패키지 vsftpd를 설치한다.

- node2에 저장소를 추가한다.
  - "http://172.24.48.199/rpms/"으로 사용하도록 설정한다. 저장소 이름은 "node1"으로 한다.
  - 기존 저장소 파일은 전부 제거한다.
  - 다만, 저장소 미러링 하지 않는 경우, 기존 저장소 파일 제거하지 않는다.
  - 추가된 저장소가 잘 보이는지 'dnf repolist'로 확인한다.
  - 올바르게 구성이 되었으면 httpd패키지를 설치한다.

```bash
www-hacker, rockylinuxworld, www-user, nologin
www-user, rockylinuxworld, secure-data
data-user, rockylinuxworld, secure-data
db-user, rockylinuxworld, wheel

node1

firewall-cmd --add-serivce=http

```



```bash
                   .---> passwd 
                  /
              -----------
adduser  ---> /etc/passwd--. 
                           \
                            @ <----- usermod -aG
                           /
groupadd ---> /etc/group--' 
              ----------
                 \
                  '---> groupmod

whereis nologin     ## false
```

## SELINUX

1. SELinux(MAC): 커널수준에서 시스템 콜 접근 제어.
2. chmod/chown(DAC): 명시된 영역(사용자 혹은 퍼미션)으로 접근 제어.

이전에는 레드햇 계열만 사용하다가, 현재 모든 리눅스 배포판에서 사용하고 있음. NIST(미국)에서 지원하는 보안 솔루션 중 하나.

현재 오픈 소스에는 두 가지 MAC보안 모델 프로그램이 제공되고 있음.

- AppArmor, GNU
- SELinux, NSA -> OpenSource

현재 사용중인 리눅스에서 SELinux동작 상태 확인. 아래 명령어는 임시적으로 사용하는 명령어.
```bash
getenforce
> 1: enforcing
> 0: permissive
setenforce 0
```

영구적으로 SELinux적용 상태를 변경하기 위해서는 다음과 같이 명령어를 사용해야 됨.

1. /etc/sysconfig/selinux
2. /etc/selinux/config(default)

```bash
ls -l /etc/selinux/
> config
vi /etc/selinux/config
> SELINUX=enforcing  
> SELINUX=permissive
systemctl daemon-reload             ## systemd에 변경내용 반영 요청
dracut -f                           ## 램 디스크 강제 갱신
```

```bash
setenforce 0
vi /etc/selinux/config
> SELINUX=permissive
systemctl daemon-reload

```

"SELINUXTYPE="에 사용하는 옵션은 다음과 같다.

1. targeted: 기본적으로 프로세스 기반으로 모니터링.
2. mls: 다중보안 사용. 보통 수준별 접근이 필요한 경우 사용. NIST에 명시가 되어 있음.
3. minimum: 컨테이너 시스템과 같이 제한적으로 접근 제한이 필요한 경우.

아래와 같이 포트변경 작업을 수행한다.(node2)

```bash
dnf install httpd-core httpd -y 
dnf provides semanage                                             ## 해당 명령어가 어떤 패키지에 포함이 되어 있는지 검색
dnf install policycoreutils-python-utils

semanage port -l | grep http 
> http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010                                                        
> http_cache_port_t              udp      3130                                                                                 
> http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000                                             pegasus_http_port_t            tcp      5988                                                                                
> pegasus_https_port_t           tcp      5989   

semanage port -a -t http_port_t -p tcp 8841                       ## 변경된 포트 
semanage port -lC                                                 ## 포트 리스트 확인 

systemctl start httpd
systemctl is-active httpd
systemctl is-active firewall                                      ## 방화벽 동작 여부
firewall-cmd --add-port=8841/tcp
firewall-cmd --runtime-to-permanent                               ## 방화벽에 등록된 포트번호를 영구적으로 적용
echo "welcome to NODE2 Server" > /var/www/html/index.html
restorecon -RFvv /var/www/html/
curl localhost:8841
```


### 연습문제(SELinux)
0. 기존에 설치한 웹 서비스 제거.(dnf remove httpd -y)
1. node2에 httpd서비스 설치 후 포트를 변경.
2. SELinux는 무조건 사용.
3. semanage명령어가 없는 경우, 올바르게 동작하도록 패키지 설치.
4. 포트번호는 8723/tcp로 http_port_t에 등록.
5. /var/www/html/index.html파일에서 "Hello Httpd Node2"메세지 출력.
6. 이 페이지는 반드시 외부에서 접근이 가능해야 됨.
7. 서비스는 리부팅 이후에도 반드시 시작 및 부트업이 되어야 함.
  1. systemctl enable --now httpd
  2. reboot


# DAY 2

## Q/A


1. BTRFS

레드햇 기준으로 7.3까지 BTRFS지원. ZFS/JFS/UFS2와 같이 엔터프라이즈 파일 시스템을 제공. 
기업용 파일 시스템에서 주요 기능 중 하나가 filesystem pool.

현재 대다수 리눅스는 LVM2(IBM)기반으로 filesystem pool를 제공하고 있으나, 여전히 관리 및 유지보수가 복잡하고 어렵다. 
이러한 이유로 btrfs에서는 pool기능을 제공하고, 하위 볼륨을(subvolume)형태로 파일 시스템 공간을 제공한다. 

2. 그러면 레드햇은...?

Fedora Linux에서는 여전히 BTRFS를 제공하고 있으며, 스트림 버전인 centos, RHEL에서는 여러가지 이유로 btrfs제공하지 않음.
BTRFS는 몇가지 단점이 있는데, 첫 번째가 XFS보다 속도가 느립니다. 두 번째가 BTRFS개발 도중에 크고 작은 파일 시스템 문제가 발생. 

XFS는 아직까지 유일하게 MILL-SPEC를 충족하는 파일 시스템. 이러한 이유로 레드햇 FILESYSTEM POOL를 Stratis라는 도구로 구현 함.


3. 결론

"--btrfs-subvolume-home"은 btrfs파일 시스템 전용이기 때문에, XFS에서 제공하는 Stratis기반의 pool에서는 사용이 안됨. 위 옵션은 레드햇 계열 배포판(xfs)에서는 사용이 불가능.


## crontab

앞으로 이 프로그램을 사용하지 않음. systemd기반에서는 ".timer"자원으로 지원하며, 본래 명칭은 "systemd-timer"라고 부른다.
systemd-timer에 통합된 자원은 다음과 같다.

1. at
2. crontab
3. anacrond

다수 배포판은 아직 crontab를 지원하기 때문에, 여전히 사용이 가능하다. 

crontab은 아래와 같은 방식으로 예약작업 등록이 가능하다.
```bash
crontab -l -u <USER>
crontab -e -u <USER>
```

/etc/cron.daily, /etc/cron.monthly와 같은 디렉터리는 "cronie-anacron"이라는 동기화 작업 스케줄러 서비스. 

```bash
ls -l /etc/cron*
> daily
> weekely
> monthly
rpm -qa cronie-anacron
rpm -ql cronie-anacron
> 
systemctl status crond.service 
systemctl is-enabled crond.service
systemctl is-active crond.service
```

이전에 crond에서 구성이 되었던 서비스는 현재는 전부다 systemd-timer로 이전이 되었음. 아래 명령어로 확인이 가능.

```bash
systemctl -t timer 
```

아직까지는 대다수 서비스는 crontab기반으로 구성 및 설정. "-u"옵션이 설정이 되어 있지 않으면, 기본적으로 root로 출력 및 편집.

아래는 crontab에서 사용하는 정책 설명.

"\*", 모든 분 혹은 모든 시간에 실행.

```bash
cat /etc/crontab                                         ## 정책 파일

# */1: 같은 동작, 권장은 "매 X분마다 실행" 

1 * * * *: 1시 1분, 2시 1분, 3시 1분.....
*/1 * * * *: 1시 1분, 1시 2분, 1시 3분...... 
```

```bash

## 매 1분마다 Hello Node1를 출력하라.
## 사용자 user3에게 작업을 할당.

# -e: edit의 약자, 특정 사용자의 작업 등록 및 편집
# -l: list의 약자, 특정 사용자의 작업 목록 출력
# -u: user의 약자, 사용자 지정

EDITOR=nano crontab -e -u testuser1  

crontab -e -u user3                                      ## 특정 사용자에게 작업 등록
crontab -l -u user3                                      ## 특정 사용자에게 등록된 작업 내용

ls -l /var/spool/cron/testuser1
cat /var/spool/cron/testuser1
> */1 * * * * echo hello world
```


### 작업 확인

```bash
journalctl -u crond -p info -fl
## 혹은   
tail -f /var/log/cron                                    ## 사용자 작업 파일
```

### 연습문제(node1)

사용자가 없는 경우, 사용자를 생성하고 아래와 같이 crontab작업을 등록한다.

1. 사용자 testuser3, testuser4를 생성한다. 암호는 rockylinux으로 한다.
2. 각 사용자에 "Hello hacker world this is 10 messages"메세지가 출력 되도록 한다.
3. 위의 매세지는 매 10분마다 출력되게 한다.



### grep

특정한 문자열을 포함하거나 혹은 시작과 끝 문자열을 검색한다. 많이 사용하는 옵션은 -R과 -i가 있다.

```bash
## 대소문자 상관 없이 검색 -i
## 하위 디렉터리까지 검색 -R

grep -Ri GNU /usr/share/doc/ 
grep -Ri GNU /usr/share/doc/ > /root/gnu_words.txt

grep -R GNU /usr/share/doc/ > /root/gnu_words.txt

grep -Ev '^#|^$' /etc/httpd/conf.d/httpd.conf
      ----
      -e: egrep 
      -v: excludes(제외)
```

### 연습문제(node1)
---

/usr/share/doc에서 license라는 대문자 단어만 찾아서 /root/materials/license.txt파일에 저장한다.


## 압축

1. tar: 여러 파일을 묶기 기능.
2. xz: 현재 대다수 리눅스 배포판은 .xz으로 압축파일 표준. 현재는 bz2대신 사용중.
3. gzip: GNU 라이센스 기반의 압축.
4. bzip2: 현재 레거시로 소프트웨어로 변경이 되어서 현재는 기본 값으로 설치가 안됨.
5. zip: BSD 라이선스 기반. 기존에 압축된 "winzip"를 파일을 풀때는, "unzip"를 통해서 해제 가능.

```bash
rpm -qa | grep zip
> bzip2-libs-1.0.8-8.el9.x86_64
> unzip-6.0-56.el9.x86_64
> gzip-1.12-1.el9.x86_64
> zip-3.0-35.el9.x86_64
> bzip2-1.0.8-8.el9.x86_64   

dnf install xz gzip -y
```

### 파일 묶기 

파일 압축 시, 보통 다음과 같은 과정으로 처리가 된다.

```bash

tar czf /root/archive.tar.gz  /usr/share/docs
    ---
    \
     `---> c: create
      ---> z: GNU Zip
      ---> f: file
gzip arhcive.tar
> archive.tar.gz      

tar cJf /root/archive.tar.xz /usr/share/doc
    ---
    \
     `---> J: XZ 

tar cf /root/archive.tar /usr/share/doc

tar xf -C /tmp archive.tar

xz /root/archive.tar
> archive.tar.xz

file archive.tar
>
file archive.tar.xz
> archive.tar.xz: XZ compressed data

tar cf --> <NAME>.tar --> xz <NAME>.tar --> <NAME>.tar.xz == tar cfJ <NAME>.tar.xz <TARGET>
```

### 주의사항

"-v" 옵션을 압축이나 혹은 해제하는 과정에서 사용하면, CPU 및 메모리 사용율이 올라감.

"tar: Removing leading `/' from member names"와 같은 메세지가 출력. 이 부분은 오류가 아니며, 아래 링크 참조.

[removing leading /](https://unix.stackexchange.com/questions/59243/tar-removing-leading-from-member-names)


### 연습문제

다음 디렉터리를 압축해서 /tmp에 보관.
- /usr/share/doc, bzip, doc.tar.bz2
- /usr/local, xz, local.tar.xz
- /var/log, gzip, log.tar.gz


## 파일 및 디렉터리 검색 

find명령어는 다음과 같이 사용한다.

정확하게 문자열 일치.
```bash
find / -name test -type f -print
```

문자열일 포함이 되어 있는거.
```bash
find / -name *test -type f -print
```

특정 결과를 실행하는 옵션.
```bash
# -print: newline
# cp test1
# cp test2
find / -name *test -type f -print -exec cp -a {} /tmp \;
                                 |
    /usr/bin/gr2fonttest        --->  cp -a {} /tmp/ \;
    --------------------                 --
           표준출력                       \
                                          `---> 파일 속성 그대로 복사.
                                      표준입력으로 전달
# -print0: none-newline 
# cp test1 test2
find /tmp/ -name '*test' -type f -print0 | xargs -0 /bin/rm -f 
           표준출력                --->    표준입력
man find
> exec                                          
```

쉘 스크립트 작성 시, 가급적이면 __샵뱅(#!)__ 를 넣어주세요.

```bash
vi search.sh
> #/bin/bash
> find / -atime +365 -size +500M -type f -print -exec cp -a /tmp/latest_access_files/ {} \;
```

```bash
#!/bin/bash
mkdir -p /root/test_files/
find / -name *test -type f -print -exec cp -a {} /root/test_files \;
```

```bash
## stat <파일경로> 
stat /usr/libexec/grubby/rpm-sort
  File: /usr/libexec/grubby/rpm-sort
  Size: 15736           Blocks: 32         IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 67322266    Links: 1
Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Context: system_u:object_r:bin_t:s0
Access: 2023-05-15 11:00:02.925008563 +0900 <-- 이 부분이 -atime(access time) 기록
Modify: 2022-11-02 08:09:40.000000000 +0900
Change: 2023-05-15 10:59:13.740214202 +0900
 Birth: 2023-05-15 10:59:13.740214202 +0900

``` 

### find 옵션 설명

1. -mtime: 파일 변경 시간 조건.
2. -atime: 파일 접근 시간 조건.
3. -user: 사용자 이름.
4. -type: 자원 형식. file=f, directory=d, link=l
5. -perm: 퍼미션 유형. 0700,rwx.
6. -exec: find에서 나온 출력 결과물을(stdout) 다른 명령에서 표준입력(stdin)으로 실행.
7. -size: 특정 크기의 파일을 검색.
8. -nouser: 사용자가 지정이 안된 파일.
9. -nogroup: 그룹이 지정이 안된 파일.
10. -print: newline.
11. -print0: none-newline.


시스템에 사용자나 혹은 그룹이 할당이 안된 파일을 찾고 싶은 경우.

```bash
adduser testuser00
userdel testuser00
find / -nouser -nogroup           ## 사용자 및 그룹이 선언이 안되어 있는 파일
```


```bash
mkdir -p /tmp/wrongfiles/

find / -user user1 -type f -print 

touch /usr/share/doc/user1.txt
chown -Rf user1. /usr/share/doc/user1.txt

find / -user user1 -type f -exec cp -a {} /tmp/user1_backup \;
                                       --

                    .---------------------------->      /home/user1/.bash_profile x 10
                   /          표준출력                  -------------------------
                  /                                                  |
  ---------------------------------                                  v
{ find / -user user1    -type   f   }     -perm 644    -exec cp -a {   } /tmp/wrongfiles/ \; x 10
               -----           ---              ---                -----               --
               사용자         자원형식                              치환              명령어 끝
```

### 연습문제

- 사용자 user1/2/3/4/5를 생성. 없으면 사용자 구성. 비밀번호는 rockylinux으로 설정.
  + 각 사용자 홈 디렉터리에 README.txt파일이 있어야 됨.
  + 각 README.txt파일은 올바르게 소유권 및 퍼미션 구성이 되어 있어야 됨.
- /tmp/user1, user2, user3, user4, user5 백업 디렉터리 생성.
- 각각 사용자가 사용하고 있는 모든 파일 및 디렉터리를 각각 백업 디렉터리에 복사.
- 복사된 백업 디렉터리 내용은 gzip로 압축.
- 스크립트 파일 이름을 backup_user.sh으로 생성.
  + 이 스크립트는 사용자 user5를 백업한다.
  + user5사용자만 xz파일로 압축한다.
  + 백업 위치는 /opt/backup-user/user5
  + 모든 작업은 스크립트로 동작한다.
  + 파일 압축도 스크립트로 진행한다.



## 네트워크 설정

현재 모든 리눅스 배포판은 다음과 같이 네트워크 관리자를 변경하고 있음.

1. NetworkManager
2. systemd-networkd(default)
3. netplan(ubuntu)
4. SuSE(wicked)


네트워크 스크립트가 레드햇 기준 9버전부터 더 이상 지원하지 않음. 어떻게 하면, 기존 스크립트를 호환하면서 사용이 가능할지?

```bash
NetworkManager --print-config
> # plugins=
vi /etc/NetworkManager/NetworkManager.conf
> plugins=keyfile,ifcfg-rh 
systemctl restart NetworkManager
nmcli connection migrate --plugin ifcfg-rh
ls -l /etc/sysconfig/networ-scripts/
> ifcfg-eth0
```


### 호스트이름 변경

1. 이전에는 "/etc/HOSTNAME"파일이나 혹은 "/etc/sysconfig/networks"에서 "HOSTNAME="값을 변경.
2. 현재는, 표준 방식으로 다시 변경.(유닉스 표준은 /etc/hostname에 저장).
3. systemd에서는 호스트 이름 변경을 'hostnamectl'으로 권장.

#### nmtui기반으로 변경

```bash
nmtui hostname node1.example.com
```

#### hostnamectl기반으로 변경.

```bash
hostnamectl set-hostname node1.example.com    ## 호스트 이름 변경
hostname                                      ## 호스트 이름 확인
hostnamectl
```

#### 파일로 생성 확인

```bash
cat /etc/hostname
```


### 네트워크 구성

1. 현재 사용중인 네트워크를 static으로 변경.
2. node1, node2번에 네트워크를 하나 더 추가.

작업 시 사용이 가능한 도구.

- nmcli(CLI)
- nmtui(TUI,prefer)
- nm-connection-editor(GUI)


현재 컴퓨터의 아이피 주소 및 라우트(게이트웨이)주소 확인. 'ifconfig'명령어는 더 이상 사용하지 않음.

```bash
ip link                                     ## 현재 서버의 네트워크 장치 확인
ip addr show  ---> ip a s                   ## 장치 아이피 주소 확인
ip r          ---> ip route / route         ## 라우팅 주소 확인
```



### 프로파일 변경 방법

```bash
nmtui edit
nmcli con sh
ip a s eth1
nmcli con up eth1
nmcli con sh eth1 | grep method
> ipv4.method:                            manual 
```

### 프로파일 제거 방법

```bash
nmcli con sh
nmcli con del eth1
nmtui edit
```



### 연습문제

노드1/2번에 eth1장치를 추가 후 아래와 같은 작업 수행.

- 이미 구성이 된 프로파일(profile)은 제거 후 진행.
- 인터페이스 이름은 internal.
  + 아이피 주소는 192.168.50.12으로 추가.
  + 넷마스크는 255.255.255.0으로 설정.
    * 이 부분은 비트(cidr)로 처리해야 됨
  + 게이트웨이는 192.168.50.1.
  + 도메인 정보는 192.168.50.1.
- 리부팅 이후에도 정보는 계속 남아 있어야 됨.


## 소유권 및 퍼미션

가급적이면 8진수 기반으로 퍼미션 조정은 하지 마시고, 심볼릭 기반으로 설정 권장.

```bash
chmod
          0       1       2      3      4      5     6     7    =    8진수(case문으로 구성됨)
                  x       w      wx     r      rx    rw    rwx

- chmod 744 <FILE>   1. 사용은 가능하지만, 비권장. 8진수로 하는 경우 숫자 계산이 필요
- chmod u+rwx <FILE> 2. GNU에서는 이 방식으로 사용을 매우 권장

chown
- chown tang.     <FILE> 3. "4번"과 동일한 효과
- chown tang:tang <FILE>  == chown tang.
                          == chown tang.grp
```

__심볼릭__

|값|이름   |
|--|-------|
|u | user  |
|g | group |
|o | other |
|a | all   |
|X | 디렉터리만 적용  |


| 값  | 이름      | 설명 |
|-----|-----------|------|
| u+s | bit key   | 디렉터리 및 실행파일에 적용, 프로그램이 실행할때 소유권자로 실행 --s                  | 
| g+s | bit key   | 디렉터리에 적용. 적용된 디렉터리 밑으로 파일이나 디렉터리는 그룹권한 상속. --g        |
| o+t | stick key | 디렉터리에 누구나 생성이 가능하나, 자신이 생성한 파일이나 혹은 디렉터리 제거 가능 --t |

|기호|설명         |
|----|-------------|
|+   | 퍼미션 추가 |
|=   | 퍼미션 대응 |
|-   | 퍼미션 제거 |

__MAC:__ SELinux and Mandatory Access Control (MAC)
  - selinux
  - apparmor
__DAC:__ discretionary access controls (DAC)
  - chown
  - chmod
__ACL:__ Access Control List (ACL)
  - setfacl/getfact

[mac/dac 차이점](https://www.twingate.com/blog/other/access-control-models)

```bash
chmod u+x   , g+r  , o=       <FILE OR DIR>
      u-w
      u=rwx

chmod -Rf u=rwX --> 모든 파일에는 실행 권한 할당하지 않음
                    실행 파일 및 디렉터리만 권한 유지
```      

o+t(1000): 스틱키(sticky)는 chmod명령어로 선언가능.
  - o+t, o+s는 잘못된 값이지만, 시스템에서는 오류로 표시가 안됨(echo $?)
  - 모든 사용자가 특정 디렉터리에서 파일 및 디렉터리 생성
  - 다른 유저는 자신이 만든 파일이나 디렉터리 제외하고 제거 불가능
           
1. user bitkey에 대표적인 예제는 'sudo'
2. sticky의 대표적인 예제는 "/tmp/"디렉터리

### group bitkey 구성

```bash
groupadd sharedir                     ## 이 그룹에만 읽기/쓰기 허용
mkdir /sharedir
chgrp sharedir /sharedir              ## chown :sharedir /sharedir
usermod -aG sharedir user1

## 특정 그룹에게만 파일 생성을 가능하도록 한다. 
chmod g=rwxs /sharedir
mkdir user1.dir                       ## sharedir그룹으로 상속
touch test1.md
```

### sticky 구성

```bash
## 모든 사용자가 생성이 가능. 자신이 만든 자원 삭제가능
chmod a=rwx,o+t /allsharedir
su - user3
touch user3.md                        ## 자신의 소유권 및 그룹으로 파일생성
mkdir user3.dir
```

### ACL(진도 후 진행)

```bash
setfacl -m u:user1:rwx /aclsharedir/        ## rwx 가능
setfacl -m u:user5:- /aclsharedir/          ## rwx 불가능
setfacl -m g:sharedir:rwx /aclsharedir/     ## rwx 가능     ==  chmod g+s

su - user1
tocuh /aclsharedir/user1.md
mkdir /aclsharedir/user1.dir

su - user5
touch /aclsharedir/user5.md
touch /aclsharedir/user5.dir

getfacl /sharedir/
```

### 연습문제

#### ACL 연습문제

1. 사용자 user5는 /poweracl/ 디렉터리 접근이 가능하다.
2. 사용자 user7는 /poweracl/ 디렉터리에 접근이 불가능하다.
3.  이외 모든 사용자는 /poweracl/ 접근이 불가능하다.

#### 표준 퍼미션 문제

1. 사용자 user2는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
2. 사용자 user1는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
3. /groupbit/ 디렉터리에 접근이 가능한 사용자들은 반드시 groupbit에 가입이 되어 있어야 한다.
4. /groupbit/ 디렉터리에서 생성이 되는 파일 및 디렉터리는 반드시 그룹 권한이 상속이 되어야 한다.
5. /allbit/ 디렉터리에는 모든 사용자가 파일 생성이 가능하지만, 자신이 만든 파일만 제거가 가능하다.


## RPM 저장소 미러 및 설정

### yum
RHEL 8까지 사용하던 패키지 관리자.
  - yellowdog package update manager
  - 파이선 기반으로 작성됨

### dnf(default)
RHEL 9부터 사용하는 패키지 관리자.
  - 기존 yum과 호환성 유지
  - module 기능 추가

### microdnf(container)
  - 컨테이너 이미지 생성시 많이 사용함. 

- dnf, yum의 저장소 정보 위치는, "/etc/yum.repos.d/".
- yum설정 파일은 "/etc/yum.conf", "/etc/yum/".
- dnf로 변경이 되면서 해당 파일은 "/etc/dnf.conf", "/etc/dnf/"으로 변경.
- RHEL 9, Rocky 9, CentOS-9-Stream를 사용하는 경우 __dnf__ 가 기본 사용


GPG확인을 전부 다 끄고 싶은 경우.

```bash
cat /etc/dnf/dnf.conf
[main]
gpgcheck=1 ---> gpgcheck=0
installonly_limit=3
clean_requirements_on_remove=True
best=True
skip_if_unavailable=False 
```

### 연습문제

- node2의 /etc/yum.repos.d/의 모든 파일을 제거.
- 저장소 파일을 아래 주소로 구성.
    + "https://mirror.kakao.com/linux/rocky/9.4/AppStream/x86_64/os/"
    + 내부 저장소가 구성이 되어 있는 경우 "http://10.10.10.1/rpms" 으로 구성
- 구성이 완료가 되면, httpd패키지 검색 및 설치 

## NTP(chronyd)

1. NTP프로토콜 서비스 대몬으로 chronyd를 사용.
2. 앞으로는 systemd-timedated(systemd-timesyncd)서비스로 변경.


```bash
timedatectl
```

ntp서버 동기화를 설정(chronyd). 현재는 두 가지 방식으로 NTP서버와 동기화를 지원.

- systemd-timesyncd 서비스. 현재는 선택사항.
- 구성을 위한 timedatectl명령어
- NTP 클라이언트 설정 파일은 /etc/chrony.conf

```bash
systemctl is-active chronyd
> active
systemctl status chronyd
> 
```

### 임시로 NTPD서버 생성

아래 작업은 node1번에서 수행.

```bash
timedatectl set-ntp false
timedatectl 
> System clock synchronized: no
> NTP service: inactive 

grep -Ev '^#|^$' /etc/chrony.conf 
> pool 2.rocky.pool.ntp.org iburst
> sourcedir /run/chrony-dhcp
> driftfile /var/lib/chrony/
> ...

vi /etc/chrony.conf 
> allow 10.10.10.0/24
> local stratum 2 

firewall-cmd --add-service=ntp
firewall-cmd --runtime-to-permanent
firewall-cmd --list-all

systemctl restart chronyd
```

### NTP클라이언트 설정

아래 작업은 node2번에서 수행.

```bash
rpm -qa chrony
dnf install chrony
systemctl enable --now chronyd

timedatectl
> System clock synchronized: yes 
> NTP service: active
chronyc sources
> ^* 121.162.54.1                  3   6   377    50   -252us[-2293us] +/-   32ms                                              

vi /etc/chrony.conf
> pool ~~~~
> server 10.10.10.1 iburst          ## NTP와 통신이 가능한 상태면 빠르게 ntp동기화

systemctl restart chronyd

timedatectl set-ntp true
chronyc sources
> ^* 10.10.10.1                    4   6     7     0  -4124ns[-4199us] +/- 9941us
```


### 연습문제

- node1 ntp서버를 아래 서버로 구성한다.
  + asia.pool.ntp.org
- node2 ntp서버를 아래 서버로 구성한다.
  + 10.10.10.1
- ntp서비스는 재부팅 이후에도 동작이 되어야한다.


## 종합문제

__DAY 1/2__ 에 수행한 작업 내용 기반으로 다음과 같이 서버구성을 수행한다.

1. 하이퍼바이저에 "node3"를 새로 구성한다. 
2. 가상머신에 설치되는 로키 리눅스 버전은 9.3혹은 9.4로 구성한다.
3. 설치가 된 서버에 아래와 같이 작업을 수행한다.
4. 다음과 같이 사용자 및 그룹 구성.

|그룹이름  |사용자 이름 |ID값       |
|---------|------------|-----------|
| sharegrp|user1,user2 |GID: 10000 | 
| datagrp |            |GID: 11000 |
| devel   |user3       |           |
| infra   |user4       |           |
| cloud   |user5       |           |


5. 랩에서 사용할 사용자의 쉘 구성
  - user1, bash
  - user2, 쉘 사용 금지 혹은 로그인 불가능 == nologin
  - user3, csh 
  - user4, tcsh
  - user5, fish

6. 기존에 설치 된 웹 서버 패키지가 있는 경우 제거.
7. node3에 httpd서비스 설치 후 포트를 변경.
8. SELinux는 무조건 사용.
9. semanage명령어가 없는 경우 올바르게 동작 하도록 패키지 설치.
10. 포트번호는 8723/tcp로 변경 및 설정.
  - /etc/http/conf/httpd.conf
11. /var/www/html/index.html파일에서 "Hello Httpd Node3"메세지 출력.
12. 이 페이지는 반드시 외부에서 접근이 가능해야 됨.
13. 서비스는 리부팅 이후에도 반드시 시작 및 부트업이 되어야 함.
14. 사용자 testuser3, testuser4를 생성한다. 암호는 rockylinux으로 한다.
15. 각 사용자에 "Hello hacker world this is 10 messages"메세지가 출력 되도록 한다.
16. 위의 매세지는 매 10분마다 출력되게 한다.
17. "/usr/share/doc"에서 "GNU"라는 대문자 단어만 찾아서 /root/materials/GNU.txt파일에 저장한다.
18. 다음 디렉터리를 압축해서 /tmp에 보관.
  - /usr/share/doc, bzip, doc.tar.bz2
  - /usr/local, xz, local.tar.xz
  - /var/log, gzip, log.tar.gz

20. 사용자 user1/2/3/4/5를 생성. 없으면 사용자 구성. 비밀번호는 rockylinux으로 설정.
  + 각 사용자 홈 디렉터리에 README.txt파일이 있어야 됨.
  + 각 README.txt파일은 올바르게 소유권 및 퍼미션 구성이 되어 있어야 됨.
21. /tmp/user1, user2, user3, user4, user5 백업 디렉터리 생성.
22. 각각 사용자가 사용하고 있는 모든 파일 및 디렉터리를 각각 백업 디렉터리에 복사.
23. 복사된 백업 디렉터리 내용은 gzip로 압축.
24. 스크립트 파일 이름을 backup_user.sh으로 생성.
  + 이 스크립트는 사용자 user5를 백업한다.
  + user5사용자만 xz파일로 압축한다.
  + 백업 위치는 /opt/backup-user/user5
  + 모든 작업은 스크립트로 동작한다.
  + 파일 압축도 스크립트로 진행한다.

25. 노드 3번에 eth1장치를 추가 후 아래와 같은 작업 수행.
  - 이미 구성이 된 프로파일(profile)은 제거 후 진행.
  - 인터페이스 이름은 eth1.
    + 아이피 주소는 10.10.10.3으로 추가.
    + 넷마스크는 255.255.255.0으로 설정.
      * 이 부분은 비트(cidr)로 처리해야 됨
    + 게이트웨이는 없음.
    + 도메인 정보는 없음.
  - 리부팅 이후에도 정보는 계속 남아 있어야 됨.
26. 사용자 user2는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
27. 사용자 user1는 /groupbit/ 디렉터리에 읽기쓰기가 가능하다.
28. /groupbit/ 디렉터리에 접근이 가능한 사용자들은 반드시 groupbit에 가입이 되어 있어야 한다.
29. /groupbit/ 디렉터리에서 생성이 되는 파일 및 디렉터리는 반드시 그룹 권한이 상속이 되어야 한다.
30. /allbit/ 디렉터리에는 모든 사용자가 파일 생성이 가능하지만, 자신이 만든 파일만 제거가 가능하다.
31. node3의 /etc/yum.repos.d/의 모든 파일을 제거.
  - 저장소 파일을 아래 주소로 구성.
    + http://10.10.10.1/rpms/
  - 구성이 완료가 되면, vsftpd패키지 검색 및 설치 
32. node3 ntp서버를 아래 서버로 구성한다.
  - 10.10.10.1
  - ntp서비스는 재부팅 이후에도 동작이 되어야한다.



## Q/A

> nmtui로 vlan이나 본딩 구성 시에도 아까 실습으로 보여주신 이더넷 프로파일이랑 동일하게 작업하면 되나요?
아니면 추가로 설정이 필요한 항목이 있을까요??

넵.다만 주의할 부분이 있음. 

1. nmtui는 세부 설정에서 지원이 안되는 부분이 있을수 도 있습니다. 없는 경우, cli로 처리.
2. bond장치는 지원은 하고 있음. 레드햇 9부터는 teamd를 deprecation으로 선언.
3. 2개 이상의 장치를 관리 및 사용을 하고 싶은 경우, teamd를 권장을 함.


# DAY 3

## 시작 전 랩 설정

```bash

man ssh-keygen
man -k ed25519


ssh-keygen -t ed25519 -N '' -f ~/.ssh/id_ed25519  
ls -l ~/.ssh/
> id_ed25519  
> id_ed25519.pub
ssh-copy-id root@10.10.10.2
ssh-copy-id root@10.10.10.3
vi /etc/hosts
> 10.10.10.1 node1.example.com
> 10.10.10.2 node2.example.com
> 10.10.10.3 node3.example.com
scp /etc/hosts root@node1:/etc/hosts
scp /etc/hosts root@node2:/etc/hosts
scp /etc/hosts root@node3:/etc/hosts
```

## 부팅

리눅스 커널은 별도로 __"안전모드"__ 가 존재하지 않음. 레드햇 계열의 배포판 커널은 __rescue__ 커널 이미지가 별도로 존재.

resuce를 사용하는 이유는, 부팅을 하다가 특정한 이유때문에, 예를 들어서 커널 모듈이 인식이 되지마자, 부팅이 행이 걸리던가 혹은 특정 서비스에서 커널 문제가 발생하는 경우 사용.

레스큐 모드를 사용하면, 윈도우와 동일하게 기본 모듈 드라이버로 실행이 됨.

- vmlinuz: 작은커널 이미지 
  + 현재 레드햇은 더 이상 vmlinuz사용하지 않음.
- bzimage: 큰 커널 이미지
  + initramfs-0-rescue-215e6c7df4fb48cfb13f6f97d5fadf82.img
  + initramfs-5.14.0-427.13.1.el9_4.x86_64.img

램 디스크에는 분기점 옵션이 있음. 아래 두 링크를 참조하여 기능과 역할 확인.

1. https://www.man7.org/linux/man-pages/man7/dracut.cmdline.7.html
2. https://www.kernel.org/doc/Documentation/blockdev/ramdisk.txt

```bash
linux rd.break
      rd.debug
      rd.meminfo
```


linux: grub이나 혹은 systemd-bootrec에서 사용하는 옵션.
linux16: lilo 혹은 구버전 grub에서 사용한 옵션.

```bash 
linux ~~~~ rd.break
switch_root# 

## 메모리에서 리눅스 커널 기반으로 부팅이 된 상태.
## initramfs를 통해서 램 디스크 리눅스에서 사용할 커널 모듈(드라이버)를 제공.

ls -l /lib/modules/

## 명령어가 제한이 되어 있음.

df (X)
lsblk (X)

mount | grep sysroot
> /sysroot option: ro
mount -oremount,rw /sysroot
mount | grep sysroot
> /sysroot option: rw

#
# chroot
#

chroot /sysroot/
crt> echo centos | passwd --stdin root
crt> touch /.autorelabel                      ## SELinux에게 레이블링 요청
crt> exit
crt> exit

loging: root
password: centos
```

### 연습문제

node1/2번에 루트 비밀번호를 "centos"로 변경. 단, 조건은 ramdisk에서 변경해야 됨.


## 스왑

Rocky Linux 9버전부터 다음과 같이 스왑이 변경이 되었음.

1. general swap(fileswap, blockswap)
2. RAM swap(zram)

### 일반 스왑

말 그대로 파일이나 혹은 블록 장치로 구성된 페이징 장치. 대다수 리눅스 계열은 블록 장치 기반으로 스왑을 구성.

```bash
PAGE(4K)

+--------------------+
|   MEMROY BLOCK     | ---> [slot memory] ---> CPU CACHE ---> <1/2/3/4> ---> CPU 
+--------------------+                           [SRAM]
        1GiB
         |
         |  유효도가 낮은 녀석
    <paging down>
         |
         |
         v
+--------------------+
|    MEMORY SWAP     | block, file
+--------------------+
```

1. fdisk: MBR전용(Rocky Linux 8버전까지)
2. gdisk: GPT전용

Rocky Linux 9부터는 fdisk에서 GPT도 같이 지원 함.


### 블록 기반

```bash
cfdisk /dev/sdb
fdisk -l /dev/sdb       ## MBR
gdisk -l /dev/sdb       ## GPT

mkswap                  ## 특정 블록 및 파티션에 서명
mkswap /dev/sdb3
dnf install hexedit -y
hexedit /dev/sdb3

swapon -s
> /dev/dm-1                               partition
swapon /dev/sdb3
swapon -s 
> /dev/dm-1
> /dev/sdb3

swapoff /dev/dm-1
swapoff /dev/sdb3
swapon -s
```

### 파일기반

```bash
#
# 확장자는 마음대로 정의 하셔도 상관 없습니다. :)
# 

dd if=/dev/zero of=/tempswap.img bs=500M count=1
mkswap /tempswap.img
chmod 0600 /tempswap.img 
swapon /tempswap.img
swapon -s
> /tempswap.img
swapon /dev/sdb3

swapon -s
> /dev/sdb3, parition
> /tempswap.img, file

vi /etc/fstab
> /dev/sdb3       swap    swap    defaults   0 0
> /tempswap.img   none    swap    defaults   0 0

swapoff -a
swapon -a
swpaon -s
> /dev/sdb3, parition
> /tempswap.img, file

systemctl daemon-reload
reboot
```
### 연습문제

nodeb서버에 다음과 같이 블록 장치를 추가 및 파티션 생성한다.

1. /dev/sdb블록장치를 하이퍼바이저를 통해서 추가.
2. 첫 번째 파티션은 일반 리눅스 파티션으로 생성.
3. 두 번째 파티션은 LVM2 파티션으로 생성.
4. 세 번째 파티션은 swap 파티션으로 생성.
5. 파일 기반으로 500메가짜리 스왑 생성 및 확인.
6. 블록 스왑 구성 후 올바르게 동작이 되는지 확인.
7. 파일 및 블록 스왑은 리부팅 이후에도 동작 해야됨.


## LVM2

현재 리눅스 배포판은 두 가지 파일 시스템으로 나누어 졌음.

1. btrfs(성능은 제일 낮음, 관리 기능으 우수)
2. xfs(성능은 제일 우수, 관리 기능이 부족)
3. ext4(성능도 모호, 관리 기능도 모호)

레드햇 계열 배포판은 xfs+LVM2기반으로 구성. 사전 지식으로 다음과 같은 부분이 필요.

1. 파티션 관리 기능(cfdisk)
2. 포멧(mkfs.xfs, mkfs.vfat, mkfs.ext3/4)
3. mount명령어
4. /etc/fstab

### 생성 순서

1. 파티션을 생성.
2. LVM에서 사용하는 PV/VG/LV를 구성.
3. 포멧.
4. 마운트 및 영구적 마운트 설정.


```bash
cfdisk /dev/sdb
fdisk -l | grep /dev/sdb  
> /dev/sdb1     2048 2099199 2097152   1G Linux filesystem                                                                    
> /dev/sdb2  2099200 4196351 2097152   1G Linux LVM                                                                            
> /dev/sdb3  4196352 6293503 2097152   1G Linux swap

## LVM2메타정보 생성 및 구성.

pvcreate /dev/sdb2                ## 파티션 혹은 블록 장치에 LVM장치 명시
vgcreate testvg /dev/sdb2         ## 디스크 어딘가에 메타정보를 저장

pvs                               ## pv scan
vgs                               ## vg scan

## 블록장치를 생성.

vgdisplay testvg                  ## testvg에 대한 메타정보 조회

> PE Size: 4Mib --> power(제곱근)
> Free  PE / Size       255 / 1020.00 MiB
                        ---   ------
                         \      \
                          \      `--> 크기(-L)
                           `---> 갯수(-l)
#
# 4Mib = 1 PE = 4MiB
#
lvcreate -n testlv-pe-10c -l 10 testvg
lvcreate -n testlv-pe-20c -l 20 testvg 

lvcreate -n testlv-sz-100m -L 100M testvg 

man lvcreate
> -l
> -L
lvcreate --help
```

고객의 요청.

나는 "PE Size: 16Mib"를 원해요.

```bash
pvcreate /dev/sdb1                ## 파티션 혹은 블록 장치에 LVM장치 명시
vgcreate testvg-pe /dev/sdb1         ## 디스크 어딘가에 메타정보를 저장

vgcreate -s 16m testvg-pe /dev/sdb1
        ----
        \
         `---> physicalextentsize
vgdisplay testvg-pe
> PE Size               16.00 MiB
lvcreate -n testlv-pe-20c -l 10 testvg-pe

## 만약, 이름 잘못 넣어서 눈물이 나오려고 할때!!

lvrename testvg-pe testlv-pe-20c testlv-pe-10c  

lvs
> testlv-pe-10c  

lvcreate -l 100%Free -n testlv-full testvg   
lvcreate -l 100%Free -n testlv-full testvg-pe


lvdisplay | grep "LV Path"

mkfs.ext3 /dev/testvg/testlv-pe-10c
mkfs.ext4 /dev/testvg/testlv-pe-20c
blkid

mkfs.vfat /dev/testvg/testlv-sz-100m
mkfs.xfs /dev/testvg-pe/testlv-pe-10c
blkid

> LV Path                /dev/testvg/testlv-pe-10c
> LV Path                /dev/testvg/testlv-pe-20c
> LV Path                /dev/testvg/testlv-sz-100m
> LV Path                /dev/testvg/testlv-full  # mkfs.xfs
> LV Path                /dev/testvg-pe/testlv-pe-10c
> LV Path                /dev/testvg-pe/testlv-full  # mkfs.xfs

mkfs.xfs /dev/testvg-pe/testlv-full 
mkfs.xfs /dev/testvg/testlv-full

mkdir -p /mnt/testlv-pe-10c
mkdir -p /mnt/testlv-pe-20c
mkdir -p /mnt/testlv-sz-100m
mkdir -p /mnt/testlv-full 
mkdir -p /mnt/testlv-testvg-pe-10c
mkdir -p /mnt/testlv-testvg-pe-full 


mount /dev/testvg/testlv-pe-10c /mnt/testlv-pe-10c
mount /dev/testvg/testlv-pe-20c /mnt/testlv-pe-20c
mount /dev/testvg/testlv-sz-100m /mnt/testlv-sz-100m
mount /dev/testvg/testlv-full /mnt/testlv-full
mount /dev/testvg-pe/testlv-pe-10c /mnt/testlv-testvg-pe-10c
mount /dev/testvg-pe/testlv-full /mnt/testlv-testvg-pe-full

dd if=/dev/zero of=mnt/testlv-full/dummy.data bs=100M 
dd if=/dev/zero of=/mnt/testlv-testvg-pe-full/dummy.data bs=100M

# 리사이즈 시, 반드시 앞에 "+"기호를 잊지 말고 붙여주세요.

lvresize -l +100%Free -r /dev/testvg/testlv-full
lvresize -L +100M -r /dev/testvg-pe/testlv-full
...

```

### lvm2기반으로 swap생성

```bash
cfdisk /dev/sdb
> 
vgextend rl /dev/sdb7
pvs
vgs 
lvcreate -n swap2 -l 100%Free rl 
lvs
> swap2          rl        -wi-a----- 496.00m
lvdisplay | grep "LV Path"
>   LV Path                /dev/rl/swap2
mkswap /dev/rl/swap2
swapon /dev/rl/swap2
swapon -s
```


### 연습문제

node2번에, node1번과 동일하게 디스크 추가 후 LVM2 및 파일 시스템 작업을 수행.


## Stratis(disk pool, filesystem pool)

레드햇 계열의 배포판에서 사용하며, xfs 파일 시스템만 이 기능을 제공한다. btrfs를 사용하는 배포판에서는 이 기능을 지원하지 않는다. 

1. Rocky: 7 ~ 8.3까지는 TP버전.
2. Rocky: 8.5부터 정식으로 릴리즈.

Stratis를 사용하는 목적은 XFS 기반으로 파일 시스템 풀(filesystem pool) 지원이 주요 목적. 앞으로는 XFS계열 파일 시스템에서는 더 이상 LVM2를 사용하지 않고, Startis로 전환할 예정.

XFS는 Storage pool를 제공하지 않기 때문에, 기업용으로 관리 하기가 어려운 부분이 있음. BTRFS를 사용을 하였으나, 성능 및 안전성 문제로 레드햇은 도입을 보류. 이로 인하여, 레드햇 계열의 배포판들은 전부 BTRFS를 지원하지 않음.


```bash
dnf search stratis
dnf install stratisd stratis-cli -y
systemctl enable --now stratisd

stratis pool list
stratis pool create pool1 /dev/sdc
stratis filesystem create pool1 --size 1GiB xfs_disk
stratis filesystem list

mkdir -p /mnt/xfs-disk
mount /dev/stratis/pool1/xfs_disk /mnt/xfs-disk

blkid
> /dev/mapper/stratis-1-709d22ce20b14e67aaf31779e00357b3-thin-fs-ccbcbf2b9942479cbc4cec628b8f9084: UUID="ccbcbf2b-9942-479c-bc4c-ec628b8f9084" TYPE="xfs"

vi /etc/fstab
> /dev/stratis/pool1/xfs_disk     /mnt/xfs-disk   xfs     defaults,x-systemd.requires=stratisd.service 0 0
mkdir -p /mnt/xfs-disk
mount -a
df | grep /mnt/xfs-disk
> /dev/mapper/stratis-1-5b78baed05f74713b82115653c373317-thin-fs-f77fcfb576f54c409276563b2e1b0f02
systemctl daemon-reload

man systemd.mount

```

### 연습문제

node2번에 Stratis를 구성한다.
- pool이름은 data-storage.
- filesystem은 5기가, data-disk로 구성한다.
- 블록 장치는 /mnt/data-disk로 연결이 된다.
- 리부팅 이후에도 이 장치는 올바르게 구성 및 연결이 되어야 한다.

# DAY 4

## vdo

본래 이전에는 "vdo.service"라는 이름으로 독립적으로 존재 하였으나, 현재는 LVM2의 LV자원 형식으로 통합이 되었음.

__vdo(Virtual Data Optimizer)__ 는 기능적 역할은 zfs, btrfs, ufs2에서 지원하는 __중복 데이터 최적화__ 

아직 Stratis+VDO 통합이 이루어지지 않았음. 

```bash
dnf search vdo
dnf install vdo vdo-support kmod-kvdo
systemctl status vdo.service
lvcreate --help | grep vdo
>  lvcreate --type vdo

pvcreate /dev/sdd 
vgcreate lvmvdo /dev/sdd 
lvcreate --type vdo -l 100%Free lvmvdo
lvdisplay | grep "LV Path"
> /dev/lvmvdo/vpool0
> /dev/lvmvdo/lvol0
lvdisplay /dev/lvmvdo/vpool0        ## VDO에 중복 파일 상태를 확인이 가능.
lvdisplay /dev/lvmvdo/lvol0         ## 사용자가 사용 가능한 일반 블록 디스크.
vdostats
> lvmvdo-vpool0-vpool  10481664   4194456   6287208  40%            0%


mkfs.xfs -K /dev/lvmvdo/lvol0       ## 효율적으로 사용하기 위해서 -K 옵션 사용.
                                    ## 아이노드 및 저널링 할당.
mkfs.ext4 -E /dev/lvmvdo/lvol0

blkid /dev/lvmvdo/lvol0
> /dev/lvmvdo/lvol0
df
> /dev/mapper/lvmvdo-lvol0   6209536    76400   6133136   2% /mnt/vdo
mkdir -p /mnt/vdo
mount /dev/lvmvdo/lvol0 /mnt/vdo
dd if=/dev/zero of=/mnt/vdo/0.data bs=500M count=2
vdostats
dd if=/dev/zero of=/mnt/vdo/1.data bs=500M count=2
vdostats
dd if=/dev/zero of=/mnt/vdo/2.data bs=500M count=2
vdostats
vi /etc/fstab
> /dev/lvmvdo/lvol0    /mnt/vdo    xfs   defaults  0    0
systemctl daemon-reload
```
### 연습문제

node2번에 vdo 구성한다.
- pool이름은 vdo-data-storage.
- 블록장치는 5기가, vdo-data-disk로 구성한다.
- 블록 장치는 /mnt/vdo-data-disk로 연결이 된다.
- 리부팅 이후에도 이 장치는 올바르게 구성 및 연결이 되어야 한다.

## /etc/fstab, autofs

1. 이 파일은 더 이상 부팅 시 사용하지는 않음.
2. fstab파일을 참조하여, systemd에서 .mount 유닛을 생성 후 블록장치 구성.
3. 마운트 위치에 특수문자 예를 들어서 "-"이스케이프 문자로 전환.
4. 이전에 사용하였던 autofs는 더 이상 지원하지 않음.
5. autofs -> automount자원으로 변경.


```bash
systemctl -t mount
systemctl -t automount

vi /etc/fstab
>
systemctl daemon-reload
mount -av
systemd-mount 
systemctl -t mount list-unit-files
> /mnt/testlv-full.mount

```

## container(high level, runtime engine)

레드햇 계열 배포판은 기본적으로 docker대신 Podman를 지원함. 현재 오픈소스 기반의 프로젝트는 전부 Podman기반으로 진행.


docker는 도커 하위 계층인 containerd를 분리. 현재 쿠버네티스는 crio, cri-docker, containerd를 지원하고 있음. OCI에서는 현재 표준 저수준 컨테이너 런타임은 Containerd를 지정. 

실제로는 쿠버네티스 및 쿠버네티스 계열 컨테이너 오케스트레이션 시스템은, 대다수가 cri-o기반으로 구성.

학습 및 실무에서 고수준 컨테이너 엔진이 필요하신 경우, 가급적이면 Podman으로 사용권장.

1. docker-desktop ---> podman-desktop
2. docker-engine  ---> podman

컨테이너 관리 도구는 아래와 같이 3가지로 분리가 되었다.

1. podman
2. buildah
3. skopeo

포드만은 systemd에서 사용이 가능하나, 존재하는 서비스는 API서버 용도로 사용함. API기반으로 관리가 필요하시지 않는 경우, 굳이 사용할 필요가 없음.

```bash
systemctl enable --now podman.service
```

Podman: __Pod__ __Man__ ager의 약자

### 포드만 설치

```bash
dnf search podman
dnf install podman -y
adduser containeruser
echo rocky | passwd --stdin containeruser
ssh containeruser@localhost                              ## 세션 정보로 인하여 꼭 루프백으로 접근.
  

cu$> podman login -u <ID> -p <PASSWD> <URL>              ## 로그인 단계. 프라이빗 저장소가 없기 때문에 그냥 진행.
cu$> podman search httpd                                 ## 이미지 검색
cu$> podman pull quay.io/centos7/httpd-24-centos7:latest
cu$> podman run -d -p8080:8080 --name container-web quay.io/centos7/httpd-24-centos7
cu$> podman run -d -p8080:8080 --name contianer-web docker.io/centos/httpd-24-centos7
## -p: 외부포트:컨테이너 포트
## -d: deatach, 백-그라운드 실행
## --name: 컨테이너가 생성시 사용하는 이름
cu$> podman container ls 
cu$> curl localhost:8080
> blah blah~~~

cu$> podman stop --all                                    ## 모든 컨테이너 동작 중지
cu$> podman stop container-web
cu$> podman container ls --all
> exited

## 서비스 파일 생성은 둘 중 아무거나 하나 선택.
cu$> podman generate systemd --new --files --name container-web

cu$> man -k podman-
cu$> man podman-generate-systemd               ## 무조건 맨 페이지 참고
      --> Installation of generated systemd unit files.

cu$> mkdir -p $HOME/.config/systemd/user       
cu$> mkdir -p ~/.config/systemd/user

cu$> podman container stop --all
cu$> cp container-web.service ~/.config/systemd/user
> 아래 파일명 한번 더 확인.

cu$> systemctl daemon-reload --user
cu$> systemctl list-unit-files --user
> container-web.service
cu$> systemctl status container-web --user
cu$> systemctl enable --now container-web --user
cu$> systemctl status container-web --user
cu$> curl localhost:8080 | head -1
```

### 사용자가 로그인 하지 않아도 서비스 실행이 필요한 경우

```bash
root#> loginctl enable-linger containeruser
root#> loginctl show-user containeruser | grep Linger  
root#> reboot

cu$> systemctl status container-web --user
cu$> curl localhost:8080 | head -1
```
 
### 이미지 빌드


사용자 containeruser에서 진행.


```bash
vi Containerfile
> FROM quay.io/centos/centos:stream9 --> quay.io/centos/centos:stream8    ## 안되는 경우 stream8
> RUN microdnf -> dnf

podman build . -t localhost/containeruser/httpd:24 
buildah bud -f <FILENAME>                                  ## dnf install buildah, 선택사항 :)
podman images
> localhost/containeruser/httpd:24 

mkdir htdocs/
echo "hello systemd service container" > htdocs/index.html

## -Z: SELinux Context 상속 옵션

podman run -d --name new-web-container -v /home/containeruser/htdocs/:/var/www/html/:Z -p 8081:80 localhost/containeruser/httpd:24 
curl http://localhost:8081
>hello systemd service container

```

여기까지 완료가 되시면, 위의 "new-web-container"서비스를 systemd의 사용자(user) ".service"으로 생성.


### 연습문제(컨테이너)

1. 컨테이너 이미지를 빌드한다. Containerfile은 기존에 사용한 컨테이너 파일로 진행.
2. 이미지 이름은 hello-www으로 명명한다. 태그는 test으로 명시한다.
3. 컨테이너가 실행이 되면 포트, 8082로 접근이 되어야 한다. 
- 만약, 접근이 안되는 경우 트러블 슈팅을 진행한다. 
- 컨테이너는 htdocs2디렉터리에 있는 index.html파일에 접근이 가능해야 한다.
- index.html파일에서는 "hello www service"라는 텍스트를 가지고 있어야 한다.
- /var/www/html/으로 연결이 되어야 한다. 
4. 구성된 컨테이너는 systemd기반으로 서비스 구성한다.
- 리부팅 이후에도 정상적으로 동작이 되어야 됨.
- 사용자가 로그인을 하지 않아도 서비스가 동작이 되어야 됨.


## firewalld

현재 사용하시는 firewalld는 더 이상 iptables기반으로 동작하지 않음.

nftables, iptables는 netfilter에서 관리 및 배포. 변경한 이유는, 가상머신 및 컨테이너가 많은 개수로 운영 및 관리가 되다보니, iptables기반으로 너무 느리고, 자동화가 어려움.

openstack 및 kubernetes에서 iptables기반으로 대용량 혹은 대규모로 운영시 어려운 부분이 있음.

1. RHEL 7: iptables
2. RHEL 8: nftables, iptables(호환성)
3. RHEL 9: nftables, iptables(호환성)


```bash
+------------------+
|    firewalld     |
+------------------+
      [HIGH]
       ^  # firewall-cmd 
       |
       v  # nft                 # iptables
      [LOW]                     # ebtables
+------------------+          +------------------+
|     nftables     |   ----   |     iptabels     |
+------------------+          +------------------+
       L2/L3                  |ebtables, iptables|
                              +------------------+
```

```bash
systemctl stop firewalld
systemctl enable --now firewall
# systemctl start firewalld
# systemctl enable firewalld

systemctl disable --now firewall
# systemctl stop firewalld
# systemctl disable firewalld
```

방화벽에 서비스 등록

```bash
dnf install httpd -y                            ## 패키지 포트가 8084/TCP


firewall-cmd --get-services 
firewall-cmd --get-services | grep ftp
firewall-cmd --add-service=http                 ## runtime에만 정책이 등록.
firewall-cmd --add-port=8084/tcp 

firewall-cmd --runtime-to-permanent             ## runtime ---> permanent로 저장.
```

```bash
iptables -L -n 
nft list tables
nft list table inet firewalld
```

"/lib/firewalld/services/"에 있는 파일은 패키지 업데이트 시, 다시 원상복구. 아래 기능은 서비스(service XML) 파일 오버라이딩 방법.

```bash
cp /lib/firewalld/services/http.xml /etc/firewalld/services/http.xml
vi /etc/firewalld/services/http.xml
> <port protocol="tcp" port="8888"/> 

systemctl reload firewalld     ---> /etc/firewalld/, /lib/firewalld/ 밑에서 변경된 내용을 다시 메모리에 불러옴.

firewall-cmd --complet-reload == systemctl reload firewalld
firewall-cmd --reload          ---> policy를 다시 메모리에 반영. 메모리 갱신.

firewall-cmd --remove-service=http               ## 80/TCP
firewall-cmd --add-service=http                  ## 8888/TCP
nft list table inet firewalld | grep 8080
```

### 연습문제(방화벽)

1. 포트번호 8089/TCP 등록한다.
2. vsftpd패키지를 설치한다.
3. ftp서비스가 원활이 동작 되도록 방화벽에 등록한다.
4. squid패키지를 설치한다.
5. squid서비스가 월활이 동작 되도록 방화벽에 등록한다.



## tuned

__커널 파라메타__ 를 프로파일 기반으로자 동으로 조절 해주는 도구. 

```bash
dnf install tuned -y
systemctl enable --now tuned

cd /lib/tuned/
> network-latency
cp -a /lib/tuned/network-latency /etc/tuned/power-network
tuned-adm list
> power-network
mkdir -p /etc/tuned/network-latency
vi /etc/tuned/network-latency/tuned.conf

tuned-adm active
tuned-adm profile desktop            ## 수동으로 변경
tuned-adm active                     ## 현재 사용중인 프로파일 확인

tuned-adm recommend                  ## 선택은 하지 않고, 권장 프로파일 확인
tuned-adm auto_profile               ## 알아서 프로파일 선택
tuned-adm active

tuned-adm profile desktop
cat profile_mode
> manual
cat active_profile
> desktop
```

연습문제
---
- 프로파일 AWS 프로파일로 변경한다.
- tuned에서 권장하는 프로파일를 사용한다.

## udev

"Dynamic device management", 사용자가 추가한 장치를 특정 커널 모듈을 통해서 장치 파일(mknod, node)를 생성하여 사용자에게 전달.

1. /dev/sda
2. /dev/char

이미 사용중인 장치. 예를 들어서 파티션이나 혹은, 위치변경(슬롯)을 하였을때 램 디스크는 변경된 디바이스 이름을 알 수가 없음. 이러한 이유로 'udevadm settle'로 변경사항 알림.

보통은 장치 이름을 어떠한 규칙에 따라서 생성 및 구성하는지 시스템에 알려줌.

```bash

ram_disk ---> 비벗팅 ---> os_disk

systemctl daemon-reload(/etc/fstab)
udevadm settle(/dev/????)
   |
[systemd] reboot
   |
   v
dracut -f
```

## autofs(--> automount)

특정 디렉터리를 NFS와 같은 공유 파일 시스템을 통해서 자동적으로 연결 및 구성.

1. 최소 NFS서버나 혹은 samba서버가 있어야 됨.
2. 클라이언트 서버에는 autofs설치가 가능해야 함. 


### 서버(node1)

```bash
dnf install autofs -y
dnf install nfs-utils -y 

systemctl enable --now nfs-server
systemctl enable --now autofs

setenforce 0

mkdir -p /srv/nfs/indirect/nfs-user1
mkdir -p /srv/nfs/indirect/nfs-user2
mkdir -p /srv/nfs/direct/nfs-user3

ls -l /etc/exports
ls -ld /etc/exports.d/
vi /etc/exports
> /srv/nfs/indirect/nfs-user1   *(rw,sync)      ## 다이렉트 
> /srv/nfs/indirect/nfs-user2   *(rw,sync)      ## 다이렉트
> /srv/nfs/direct/nfs-user3     *(rw,sync)      ## 다이렉트
exportfs -avrs

systemctl stop firewalld                        ## 방화벽 싫으면 끄세용!

firewall-cmd --add-service=nfs
firewall-cmd --add-service=nfs3
firewall-cmd --add-service=rpc-bind

showmount -e 10.10.10.1
> Export list for 10.10.10.1:
> /srv/nfs/direct/nfs-user3   *
> /srv/nfs/indirect/nfs-user2 *
> /srv/nfs/indirect/nfs-user1 *
```

### 클라이언트(node2)

```bash
dnf install nfs-utils autofs -y
adduser -M nfs-user1                ## 사용자 홈 디렉터리 생성하지 않음.
adduser -M nfs-user2
adduser -M nfs-user3
echo rocky | passwd --stdin nfs-user1
echo rocky | passwd --stdin nfs-user2
echo rocky | passwd --stdin nfs-user3

getent passwd nfs-user1
getent passwd nfs-user2
getent passwd nfs-user3

## -------------------------

showmount -e 10.10.10.1       ## 서버 아이피, node1번 아이피 입력 해주세요.
> exporting *:/srv/nfs/indirect/nfs-user1
> exporting *:/srv/nfs/indirect/nfs-user2
> exporting *:/srv/nfs/direct/nfs-user3

mount 10.10.10.1:/srv/nfs/indirect/nfs-user1 /mnt/
umount /mnt
```

### in-direct 구성

```bash
vi /etc/auto.master.d/indirect.autofs                 ## 무조건 확장자가 .autofs
> /home/               /etc/auto.indirect
        nfs-user1
vi /etc/auto.indirect
> *       -rw,sync       10.10.10.1:/srv/nfs/indirect/&
  --
  /home/*          --검색-->                          nfs-user1 "&"백그라운드 동작        
> ## mount -t nfs 10.10.10.1:/srv/nfs/indirect/nfs-user1 /home/nfs-user1 &

ssh nfs-user1@localhost
> pwd
> /home/nfs-user1

systemctl enable --now autofs
```


### direct 구성

```bash
vi /etc/auto.master.d/direct.autofs
> /-               /etc/auto.direct
  ---
  바로 사용자가 명시한 디렉터로 연결

vi /etc/auto.direct
> /home/nfs-user3      -rw,sync       10.10.10.1:/srv/nfs/direct/nfs-user3

ssh nfs-user3@localhost
> pwd
> ls /home/

mount | grep nfs-user3
> /etc/auto.direct on /home/nfs-user3 type autofs (rw,relatime,fd=13,pgrp=4729,timeout=300,minproto=5,maxproto=5,direct,pipe_ino=37345)
systemctl disable --now autofs
reboot

```
